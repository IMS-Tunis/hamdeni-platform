<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IGCSE Computer Science - 1.1: Number systems</title>
  <link rel="stylesheet" href="../igcse-style.css">
</head>
<body>

<div class="container">

<div class="header-container">
<img src="../syllabus.png" alt="Syllabus Update" class="top-right-icon">
  <div class="title-row">
    <h1 class="section-title">1.1: Number systems</h1>
  </div>
  <div class="title-underline"></div>
  <p class="section-subtitle">Computer Science IGCSE notes, prepared by Dr. Hamdeni</p>
</div>
  <div class="section">
    <h2>1.1a: How and why computers use binary to represent all forms of data</h2>
    <ul>
	
	 <li><span class="official-note">As humans, we process data that is called  <span class="keyword" data-tooltip="a continuous stream of data that is processed by humans.">analogue data</span>. Everything we see, hear, feel and smell is a continuous stream of analogue data to our senses. </span>
      </li>
	  
      <li><span class="official-note">Computers process all data in binary using electronic switches with two states (ON or OFF), so any form of data is converted into 0s and 1s before processing.</span>
        <ul>
          <li><span class="official-note">Inside the computer, many ON or OFF switches are combined in <span class="keyword" data-tooltip="a very small component in a computer system that controls the flow of electricity.">logic gates</span> (switch-based operations that output 0 or 1) to process and store <span class="keyword" data-tooltip="discrete data that only uses the values O and 1.">digital data</span> (since they cannot process analogue data). This digital data is stored in <span class="keyword" data-tooltip="a small component in a computer system that is used to temporarily store data.">registers</span>. </span></li>
          </ul>
      </li>
      <li><span class="official-note">In binary hardware, OFF is represented by 0 and ON by 1.</span>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><span class="fun-tip">Analogue is like a dimmer switch that slides smoothly; digital is like a normal switch with only OFF=0 or ON=1.</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1a')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1a')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>1.1b: Denary, binary, and hexadecimal; conversions among them</h2>
    <ul>
      <li><span class="official-note">Denary is base 10 using digits 0 to 9; binary is base 2 using digits 0 and 1; <span class="keyword" data-tooltip="a number system based on the value 16 which uses denary digits 0 to 9 and letters A to F">hexadecimal</span> is base 16 using symbols 0 to 9 and A to F.</span>
        <ul>
          <li><span class="official-note">In hexadecimal, the letters map to denary values: A=10, B=11, C=12, D=13, E=14, F=15.</span></li>
          <li><span class="official-note">In an 8-bit layout, the place-value headings are 128, 64, 32, 16, 8, 4, 2, 1.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Denary place values: 123 has 1 hundred (10^2), 2 tens (10^1), and 3 ones (10^0), which anchors the idea of place value before conversions.</div></li>
    </ul>
    <ul>
      <li><span class="official-note">The leftmost bit of a binary number is the most significant bit (MSB).</span>
        <ul>
          <li><span class="official-note">The rightmost bit of a binary number is the least significant bit (LSB); it has the smallest place value.</span></li>
          </ul>
      </li>
      <li><span class="official-note">To convert a positive denary number to binary, list the binary place values and mark each column with 1 if it is used and 0 if it is not, subtracting used values until the remainder is 0.</span>
        <ul>
          <li><span class="official-note">Alternative method: divide the denary number by 2 repeatedly and read the remainders from bottom to top to form the binary number.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">13 to 4-bit binary: Use 8 and 4, skip 2, use 1. Result 1101. This shows how marking columns builds the binary result.</div></li>
      <li><div class="example-box">59 to 8-bit binary: Use 32 + 16 + 8 + 2 + 1. Result 00111011. This confirms the step-by-step method.</div></li>
    </ul>
    <ul>
      <li><span class="official-note">To convert binary to denary, add the place values for all columns that contain a 1.</span>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">1010 to denary: Add 8 + 2 to get 10. This illustrates adding headings where bits are 1.</div></li>
    </ul>
    <ul>
      <li><span class="official-note">Hexadecimal and binary convert directly because one hex digit corresponds to exactly four binary bits; split or group binary in fours and map each group to a hex digit.</span>
        <ul>
          <li><span class="official-note">When converting binary to hexadecimal, group bits from the right in sets of four; if the leftmost group has fewer than four bits, pad it with leading zeros.</span></li>
          <li><span class="official-note">One way to convert hexadecimal to denary is to first write each hex digit as 4-bit binary, then add the binary place values where the bits are 1.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">101111100001 to hex: Group as 1011 1110 0001 and map to B E 1, giving BE1.</div></li>
      <li><div class="example-box">201 to hex: Write binary 11001001, split as 1100 and 1001, map to C and 9, giving C9.</div></li>
      <li><div class="example-box">Hex to binary: A2 â†’ A is 1010 and 2 is 0010, so the binary is 10100010. This shows the reverse mapping from hexadecimal to binary.</div></li>
      <li><div class="example-box">Hex to binary with three hex digits: 45A â†’ 0100 0101 1010, then write without spaces as 010001011010. This reinforces grouping by fours.</div></li>
      <li><span class="fun-tip">Binary place values are like a set of weights that double each time. With weights 1, 2, 4, 8, 16, you can make any whole number by picking some weights and leaving others, just like putting 1s and 0s under the headings.</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1b')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1b')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>1.1c: Why hexadecimal is a beneficial data representation</h2>
    <ul>
      <li><span class="official-note">Hexadecimal is shorter than binary and easier for humans to read, write, and check, so programmers use it to inspect and debug data.</span>
        <ul>
          <li><span class="official-note">A common use is writing device hardware addresses in hexadecimal.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Hex shortens binary: The 12-bit binary 101111100001 becomes the 3-symbol hex BE1 by grouping into fours and mapping, which makes long values quicker to compare.</div></li>
      <li><div class="example-box">Readability of a long value: The long binary 10011100101110111000111011100010111101011010 becomes 9CBB8EE2F5A in hexadecimal, making differences easier to spot.</div></li>
      <li><div class="example-box">HTML colour code: #FF0000 represents red. Hex pairs give the intensities for red, green, and blue, which shows a practical use students see on web pages.</div></li>
      <li><span class="fun-tip">Hexadecimal is a nickname for long binary. Saying BE1 instead of 101111100001 is like using a short contact name on your phone instead of the full number.</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1c')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1c')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>1.1d: Add two positive 8-bit binary integers; overflow</h2>
    <ul>
      <li><span class="official-note">Binary addition follows fixed rules applied column by column from right to left, carrying a 1 to the next column when required.</span>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Worked 8-bit addition with carries: 10010100 + 00011110 â†’ add each column right to left and record any carry above the next column; the final 8-bit sum is 10110010. This shows how carries build the result.</div></li>
    </ul>
    <ul>
      <li><span class="official-note">In 8-bit arithmetic, <span class="keyword" data-tooltip="a type of error that occurs when a number larger than a register can store is generated.">overflow</span> occurs when the true result needs a ninth bit; the stored 8-bit answer then does not match the correct denary total because the extra carry is lost.</span>
      </li>
      <li><span class="official-note">When 8-bit addition produces a ninth leftmost bit, that extra bit is the overflow bit and shows the result exceeds 8-bit capacity.</span>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Overflow on 8-bit addition: 01101110 + 11011110 produces a 9th carry; the truncated 8-bit answer 01001100 equals 76, but the true denary sum is 332, which demonstrates overflow.</div></li>
      <li><span class="fun-tip">If your answer has more bits than allowed, that extra leftmost bit is overflow: the computer can't fit it!</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1d')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1d')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>1.1e: Logical binary shifts on positive 8-bit integers and their effect</h2>
    <ul>
      <li><span class="official-note">A logical shift moves all bits left or right; bits that move past the edge are lost and zeros fill the emptied positions.</span>
        <ul>
          <li><span class="official-note">Each left shift doubles your number; each right shift halves it.</span></li>
          <li><span class="official-note">In shift operations, the LSB is the rightmost bit that can be pushed out during a <span class="keyword" data-tooltip="an operation that shifts bits to the left or right in a register; any bits shifted out of a register (left or right) are replaced with zeroes">right shift</span>; zeros fill the left as bits move right.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Multiply or divide by shifting: Starting from a value equal to 44 in denary, one logical left shift gives 88 and one logical right shift gives 22.</div></li>
      <li><div class="example-box">Losing the most significant 1-bit (MSB) after repeated left shifts: Starting from 00010101 (denary 21), left-shift once: 00101010 (42); twice: 01010100 (84); three times: 10101000 (168); four times: 01010000 (80). The fourth shift discards the MSB 1, so the value is not equal to 21Ã—16 in 8 bits, which shows why losing edge bits changes the expected doubling.</div></li>
      <li><div class="example-box">Shift limit to zero in 8 bits: Starting from 00011000 (denary 24), left shift five times: 00110000 (48), 01100000 (96), 11000000 (192), 10000000 (128), 00000000 (0). Repeated shifts push all 1-bits out of the 8-bit register, leaving 0.</div></li>
      <li><span class="fun-tip">Picture 8 seats in a row. Shift right: everyone moves one seat right, the last student falls off the edge, and a new empty seat appears at the left as 0. Shift left: everyone moves one seat left, the first student falls off, and a new empty seat appears at the right as 0.</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1e')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1e')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>1.1f: Twoâ€™s complement representation of positive and negative 8-bit integers</h2>
    <ul>
      <li><span class="official-note">To represent a negative number in twoâ€™s complement, write the positive value in binary, invert every bit, and add 1.</span>
        <ul>
          <li><span class="official-note">Positive integers are stored the same as normal binary with the leftmost bit 0 (MSB=0).</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">âˆ’35 in 8 bits: Write +35 in binary, invert the bits, then add 1 to obtain the twoâ€™s complement form; this shows the standard construction of a negative value.</div></li>
    </ul>
    <ul>
      <li><span class="official-note">With 8 bits in twoâ€™s complement, the range is âˆ’128 to +127, and the leftmost bit indicates whether the number is negative or positive.</span></li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Decode a negative value to denary: 10010011 has signed headings âˆ’128, 64, 32, 16, 8, 4, 2, 1; add the positions with 1s: âˆ’128 + 16 + 2 + 1 = âˆ’109. This shows reverse conversion from binary to denary in twoâ€™s complement.</div></li>
      <li><span class="fun-tip">To get a negative number: "Flip all the bits and add one!" (Thatâ€™s the computerâ€™s trick.)</span></li>
    </ul>
    <ul class="no-bullets">
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('1.1f')">
          ğŸ”‘ View Keywords on This Topic ğŸ”‘
        </button>
        <button class="exam-button" onclick="openPopupQ('1.1f')">
          ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
        </button>
      </div>
    </ul>
  </div>
</div>

  <script src="popup-script.js"></script>
  <script>
    window.addEventListener('load', function() {
      var height = document.body.scrollHeight;
      window.parent.postMessage({type: 'resize', height: height}, '*');
    });
  </script>
</body>
</html>