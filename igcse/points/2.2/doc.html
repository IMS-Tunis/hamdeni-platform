<!DOCTYPE html>
<html lang="en">
<head>
<script src="/assets/js/storage-fallback.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NRRL1TSE7Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NRRL1TSE7Z');
</script>

  <title>IGCSE Computer Science: 2.2 Methods of error detection</title>
  <link rel="stylesheet" href="../igcse-style.css">
<script defer src="/assets/js/paste-guard.js"></script>
</head>
<body>


<div class="container">
<div class="header-container">
<img src="../syllabus.png" alt="Syllabus Update" class="top-right-icon">
  <div class="title-row">
    <h1 class="section-title">2.2 Methods of error detection</h1>
  </div>
  <div class="title-underline"></div>
  <p class="section-subtitle">Computer Science IGCSE notes, prepared by Dr. Hamdeni</p>
</div>

  <div class="section">
    <h2>2.2a: Understand the need to check for errors after data transmission and how these errors can occur</h2>
    <ul>
      <li><span class="official-note">Data sent across a network can be corrupted, lost, gained, or changed during transmission, so error checking is necessary to detect problems.</span>
        <ul>
          <li><span class="official-note">Interference during transmission can cause errors, so checking is required to detect them.</span></li>
        </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Example: scrambled text and computers. A short sentence with letters scrambled may still be readable by a human, but a computer cannot interpret corrupted data. This shows why exact, error-free transmission is important for machines.</div></li>
      <li><span class="fun-tip">Think of sending a box of cookies: data loss is missing cookies, data gain is extra crumbs that do not belong, and data change is a cookie turned into a cracker. A computer cannot guess the original recipe, so we must check the box when it arrives.</span></li>
      <li>
        <div class="button-group">
          <button class="keyword-button" onclick="openPopupK('2.2a')">
            ğŸ”‘ View Keywords on This Topic ğŸ”‘
          </button>
          <button class="exam-button" onclick="openPopupQ('2.2a')">
            ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
          </button>
        </div>
      </li>
    </ul>
  </div>
  <div class="section">
    <h2>2.2b: Describe the processes involved in parity check, checksum, and echo check</h2>
    <ul>
      <li><span class="official-note"><span class="keyword" data-tooltip="a method used to check if data has been transferred correctly; it makes use of even parity (an even number of 1-bits) or odd parity (an odd number of 1-bits)">parity check</span> adds a <span class="keyword" data-tooltip="a bit (either 0 or 1) added to a byte of data in the most significant bit position; this ensures that the byte follows the correct even parity or odd parity protocol">parity bit</span> so that the total number of 1 bits in each byte follows an agreed rule of odd parity or even parity. In this context, a byte is formed by 7 data bits plus 1 parity bit, for a total of 8 bits. The receiver counts the 1s and flags an error if the parity rule is broken.</span>
        <ul>
          <li><span class="official-note">Odd parity means the total number of 1s is odd, and even parity means the total number of 1s is even.</span></li>
          <li><span class="official-note">Agreement and checking process: before transmission, the sender and receiver agree which parity type will be used, and after transmission the receiver recalculates parity to check for errors.</span></li>
          <li><span class="official-note">Limitation of single-byte parity: if an even number of bits are flipped during transmission, the overall parity can remain the same and the error may not be detected.</span></li>
          <li><span class="official-note"><span class="keyword" data-tooltip="a horizontal and vertical parity check on a block of data being transmitted">parity block</span> check: arrange bytes in a grid and apply parity across rows (horizontal) and columns (vertical) using a <span class="keyword" data-tooltip="an extra byte of data sent at the end of a parity block; it is composed of the parity bits generated from a vertical parity check of the data block">parity byte</span>. If one row and one column fail parity, their intersection identifies the bit in error; correct that bit or re-send the block.</span></li>
        </ul>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="a verification method used to check if data transferred has been altered or corrupted; calculated from the block of data of data being sent; the checksum value is sent after each data block">checksum</span> calculates a value from a block of data before transmission and sends it with the data. The receiver recalculates the checksum from the received block and compares the two values. A mismatch indicates an error and the data is re-sent.</span>
        <ul>
          <li><span class="official-note">Agreed method: the checksum is calculated using an algorithm agreed by the sender and receiver, and the same agreed method is used again at the receiver to verify the block.</span></li>
        </ul>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="a method used to check if data has been transferred correctly; data is sent to a receiver and then immediately sent back to the sender; the sender then checks if the received data matches the sent data">echo check</span> sends the received data back to the sender. The sender compares the echo to the original. A match suggests correct transmission, and a difference indicates an error.</span>
        <ul>
          <li><span class="official-note">Limitation: if the original and echoed data differ, it is not known whether the error occurred on the way to the receiver or on the way back.</span></li>
        </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Example: even-parity mismatch. Sent byte 01011100 has four 1s, which is even. If the receiver gets 01001100, it has three 1s, which is odd. Because even parity was agreed, the mismatch in the count of 1s indicates an error.</div></li>
      <li>
        <div class="button-group">
          <button class="keyword-button" onclick="openPopupK('2.2b')">
            ğŸ”‘ View Keywords on This Topic ğŸ”‘
          </button>
          <button class="exam-button" onclick="openPopupQ('2.2b')">
            ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
          </button>
        </div>
      </li>
    </ul>
  </div>
  <div class="section">
    <h2>2.2c: Describe how a check digit is used to detect errors in data entry and identify examples of use</h2>
    <ul>
      <li><span class="official-note">A <span class="keyword" data-tooltip="an additional digit appended to a number to check if the entered number is error-free; check digit is a data entry check and not a data transmission check">check digit</span> is calculated from the other digits in a code and stored as the final digit. When the code is entered or scanned, the check digit is recalculated and compared to the stored value to detect entry errors.</span>
        <ul>
          <li><span class="official-note">Check digits are used in barcodes and International Standard Book Numbers.</span></li>
          <li><span class="official-note">Common data entry errors detected include wrong digits, transpositions of two digits, and missing or extra digits.</span></li>
        </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">Example: ISBN-13 check digit. Add the digits in the odd positions. Add three times the digits in the even positions. Sum these results and take the remainder when divided by 10. If the remainder is zero, the check digit is 0. Otherwise it is 10 minus the remainder. For 978034098382, the remainder is 1, so the check digit is 9 and the full code is 9780340983829. Verification repeats the process including the check digit and expects a remainder of 0.</div></li>
      <li><div class="example-box">Example: modulo-11 method. Multiply each digit by a weight from 8 down to 2, add the products, divide by 11, and use 11 minus the remainder as the check digit, using X if the remainder is 10. For the base 4156710 the total is 130, the remainder is 9, so the check digit is 2. Verification with weights 8 down to 1 gives a remainder of 0.</div></li>
      <li><span class="fun-tip">The check digit is like a quick maths riddle at the supermarket. If the totals do not add up when the last digit is checked, the till asks for a rescan because a digit was entered wrongly.</span></li>
      <li>
        <div class="button-group">
          <button class="keyword-button" onclick="openPopupK('2.2c')">
            ğŸ”‘ View Keywords on This Topic ğŸ”‘
          </button>
          <button class="exam-button" onclick="openPopupQ('2.2c')">
            ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
          </button>
        </div>
      </li>
    </ul>
  </div>
  <div class="section">
    <h2>2.2d: Describe how an automatic repeat request can be used to establish that data is received without error</h2>
    <ul>
      <li><span class="official-note">Automatic repeat request uses <span class="keyword" data-tooltip="a message sent to the receiver indicating that data has been received correctly (used in the ARQ error detection method)">acknowledgement</span>, which are messages that confirm whether reception succeeded, and a <span class="keyword" data-tooltip="the time interval allowed to elapse before an acknowledgement is received (in the ARQ error detection method)">timeout</span>, which is the maximum waiting time for an acknowledgement, to ensure that data is delivered correctly and to trigger re-transmission when necessary.</span>
        <ul>
          <li><span class="official-note">Operational flow: if a positive acknowledgement is received, delivery is confirmed. If a negative acknowledgement is received or the timeout expires, the sender re-sends the packet.</span></li>
          <li><span class="official-note">Start timer on send: when a packet is transmitted, a timer starts immediately; if the acknowledgement does not arrive before the timer expires, the sender automatically retransmits the packet.</span></li>
          <li><span class="official-note">Retries continue until a positive acknowledgement is received or a preset retry limit is reached.</span></li>
        </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><span class="fun-tip">ARQ works like a walkie-talkie exchange: â€œMessage received OK.â€ If there is silence, the sender repeats the message after waiting a short time, until the confirmation is heard.</span></li>
      <li>
        <div class="button-group">
          <button class="keyword-button" onclick="openPopupK('2.2d')">
            ğŸ”‘ View Keywords on This Topic ğŸ”‘
          </button>
          <button class="exam-button" onclick="openPopupQ('2.2d')">
            ğŸ‘ï¸ Quick Look at Exam Questions on This Topic ğŸ‘ï¸
          </button>
        </div>
      </li>
    </ul>
  </div>
</div>

  <script src="popup-script.js"></script>
</body>
</html>
