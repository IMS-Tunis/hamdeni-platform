(function(){
  var annexData = {"LinearSearchPseudo": {"kind": "pseudo", "lines": [{"visible": "", "tip": "// Linear search in a 1D array myList between lowerBound and upperBound (inclusive)\n// Checks each element in order until the item is found or the upper bound is reached"}, {"visible": "found ← FALSE", "tip": ""}, {"visible": "index ← lowerBound", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "WHILE (index ≤ upperBound) AND (found = FALSE) DO", "tip": ""}, {"visible": "    IF myList[index] = item THEN", "tip": ""}, {"visible": "        found ← TRUE", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "        index ← index + 1", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "IF found = TRUE THEN", "tip": ""}, {"visible": "    OUTPUT index", "tip": ""}, {"visible": "ELSE", "tip": ""}, {"visible": "    OUTPUT \"Not found\"", "tip": ""}, {"visible": "ENDIF", "tip": ""}]}, "LinearSearchPython": {"kind": "python", "lines": [{"visible": "def linear_search(my_list, item, lower_bound=0, upper_bound=None):", "tip": "    \"\"\"\n    Linear search: checks each element in order from lower_bound to upper_bound (inclusive)\n    until the item is found or the upper bound is reached.\n\n    Returns:\n        int: index of item if found, otherwise -1.\n    \"\"\""}, {"visible": "    if upper_bound is None:", "tip": ""}, {"visible": "        upper_bound = len(my_list) - 1", "tip": ""}, {"visible": "    index = lower_bound", "tip": ""}, {"visible": "    while index <= upper_bound:", "tip": ""}, {"visible": "        if my_list[index] == item:", "tip": ""}, {"visible": "            return index", "tip": ""}, {"visible": "        index += 1", "tip": ""}, {"visible": "    return -1", "tip": ""}]}, "BinarySearchPseudo": {"kind": "pseudo", "lines": [{"visible": "", "tip": "// Binary search in a sorted (ascending) 1D array List\n// Repeatedly checks the middle element and discards the half that cannot contain SearchItem"}, {"visible": "Found ← FALSE", "tip": ""}, {"visible": "SearchFailed ← FALSE", "tip": ""}, {"visible": "First ← 0", "tip": ""}, {"visible": "Last ← MaxItems - 1", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "WHILE NOT Found AND NOT SearchFailed DO", "tip": ""}, {"visible": "    Middle ← (First + Last) DIV 2", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF List[Middle] = SearchItem THEN", "tip": ""}, {"visible": "        Found ← TRUE", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "        IF First >= Last THEN", "tip": ""}, {"visible": "            SearchFailed ← TRUE", "tip": ""}, {"visible": "        ELSE", "tip": ""}, {"visible": "            IF List[Middle] > SearchItem THEN", "tip": ""}, {"visible": "                Last ← Middle - 1", "tip": ""}, {"visible": "            ELSE", "tip": ""}, {"visible": "                First ← Middle + 1", "tip": ""}, {"visible": "            ENDIF", "tip": ""}, {"visible": "        ENDIF", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "IF Found = TRUE THEN", "tip": ""}, {"visible": "    OUTPUT Middle", "tip": ""}, {"visible": "ELSE", "tip": ""}, {"visible": "    OUTPUT \"Item not present in array\"", "tip": ""}, {"visible": "ENDIF", "tip": ""}]}, "BinarySearchPython": {"kind": "python", "lines": [{"visible": "def binary_search(sorted_list, search_item):", "tip": "    \"\"\"\n    Binary search on a list sorted in ascending order.\n\n    Preconditions:\n        sorted_list is sorted in ascending order.\n\n    Returns:\n        int: index of search_item if found, otherwise -1.\n    \"\"\""}, {"visible": "    first = 0", "tip": ""}, {"visible": "    last = len(sorted_list) - 1", "tip": ""}, {"visible": "    while first <= last:", "tip": ""}, {"visible": "        middle = (first + last) // 2", "tip": ""}, {"visible": "        if sorted_list[middle] == search_item:", "tip": ""}, {"visible": "            return middle", "tip": ""}, {"visible": "        elif sorted_list[middle] > search_item:", "tip": ""}, {"visible": "            last = middle - 1", "tip": ""}, {"visible": "        else:", "tip": ""}, {"visible": "            first = middle + 1", "tip": ""}, {"visible": "    return -1", "tip": ""}]}, "InsertionSortPseudo": {"kind": "pseudo", "lines": [{"visible": "", "tip": "// Insertion sort\n// Values to be sorted are stored in a 1D array, List"}, {"visible": "FOR Pointer ← 1 TO NumberOfItems - 1", "tip": ""}, {"visible": "    ItemToBeInserted ← List[Pointer]", "tip": ""}, {"visible": "    CurrentItem ← Pointer - 1   // last item in the sorted part", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    WHILE (List[CurrentItem] > ItemToBeInserted) AND (CurrentItem > -1) DO", "tip": "// Move larger items one place to the right until the correct position is reached"}, {"visible": "        List[CurrentItem + 1] ← List[CurrentItem]  // move item down", "tip": ""}, {"visible": "        CurrentItem ← CurrentItem - 1              // look at the item above", "tip": ""}, {"visible": "    ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    List[CurrentItem + 1] ← ItemToBeInserted", "tip": "// Insert the item into the gap created"}, {"visible": "NEXT Pointer", "tip": ""}]}, "InsertionSortPython": {"kind": "python", "lines": [{"visible": "def insertion_sort(a):", "tip": "    \"\"\"\n    Insertion sort (ascending).\n\n    How it works:\n    - Treat the left part of the list as sorted.\n    - Take the next item (key).\n    - Shift larger items one position to the right.\n    - Insert key into the gap created.\n\n    Returns:\n        list: the same list object, sorted in ascending order.\n    \"\"\""}, {"visible": "    n = len(a)", "tip": ""}, {"visible": "    for pointer in range(1, n):", "tip": "# Start from index 1 because a[0] alone is already a sorted part"}, {"visible": "        key = a[pointer]", "tip": "# the item to insert"}, {"visible": "        current = pointer - 1", "tip": "# last index in the sorted part"}, {"visible": "        while current >= 0 and a[current] > key:", "tip": "# Shift larger items to the right"}, {"visible": "            a[current + 1] = a[current]", "tip": ""}, {"visible": "            current -= 1", "tip": ""}, {"visible": "        a[current + 1] = key", "tip": "# Insert key into its correct position"}, {"visible": "    return a", "tip": ""}]}, "BubbleSortPseudo": {"kind": "pseudo", "lines": [{"visible": "", "tip": "// Bubble sort (nested loop structure)\n// Values are stored in a 1D array MyList of size n"}, {"visible": "Unsorted ← n - 1", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "FOR i ← 0 TO n - 2", "tip": ""}, {"visible": "    FOR j ← 0 TO Unsorted - 1", "tip": ""}, {"visible": "        IF MyList[j] > MyList[j + 1] THEN", "tip": ""}, {"visible": "            Temp ← MyList[j]", "tip": ""}, {"visible": "            MyList[j] ← MyList[j + 1]", "tip": ""}, {"visible": "            MyList[j + 1] ← Temp", "tip": ""}, {"visible": "        ENDIF", "tip": ""}, {"visible": "    NEXT j", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    Unsorted ← Unsorted - 1", "tip": "// After each pass, the largest remaining item is at the end"}, {"visible": "NEXT i", "tip": ""}]}, "BubbleSortPython": {"kind": "python", "lines": [{"visible": "def bubble_sort(a):", "tip": "    \"\"\"\n    Bubble sort (ascending).\n\n    How it works:\n    - Compare neighbouring items.\n    - Swap them if they are in the wrong order.\n    - After each full pass, the largest remaining item ends up at the end,\n      so the unsorted part can shrink.\n\n    Returns:\n        list: the same list object, sorted in ascending order.\n    \"\"\""}, {"visible": "    n = len(a)", "tip": ""}, {"visible": "    unsorted = n - 1", "tip": ""}, {"visible": "    for _ in range(n - 1):", "tip": "# Repeat passes through the list"}, {"visible": "        for j in range(unsorted):", "tip": "# Compare only within the unsorted part"}, {"visible": "            if a[j] > a[j + 1]:", "tip": ""}, {"visible": "                temp = a[j]", "tip": ""}, {"visible": "                a[j] = a[j + 1]", "tip": ""}, {"visible": "                a[j + 1] = temp", "tip": ""}, {"visible": "        unsorted -= 1", "tip": "# One more item is in the correct final position"}, {"visible": "    return a", "tip": ""}]}, "linkedInitialisePseudo": {"kind": "pseudo", "lines": [{"visible": "PROCEDURE linkedInitialisePseudo(Size)", "tip": ""}, {"visible": "    NullPointer <- -1", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    StartPointer <- NullPointer", "tip": ""}, {"visible": "    FreeListPtr <- 0", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    FOR i <- 0 TO Size - 2", "tip": ""}, {"visible": "        List[i].Pointer <- i + 1", "tip": ""}, {"visible": "        List[i].Data <- Null   // optional placeholder", "tip": ""}, {"visible": "    NEXT i", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    List[Size - 1].Pointer <- NullPointer", "tip": ""}, {"visible": "    List[Size - 1].Data <- Null  // optional placeholder", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "linkedInitialisePython": {"kind": "python", "lines": [{"visible": "NULL_POINTER = -1", "tip": "Null pointer value used in this linked list"}, {"visible": "LinkedList = []", "tip": "LinkedList will store nodes as: [data, nextPointer]\nExample: LinkedList[3] = [56, -1] means:\ndata = 56\nnextPointer = -1 (end of list)"}, {"visible": "FirstNode = NULL_POINTER", "tip": "FirstNode is the start pointer (index of first node in the list)"}, {"visible": "FirstEmpty = NULL_POINTER", "tip": "FirstEmpty is the free list pointer (index of first free node)"}, {"visible": "def linkedInitialisePython(size):", "tip": "    \"\"\"\n    Create an empty linked list of a fixed size.\n    Also create a free list that chains all nodes together.\n\n    Returns nothing because it sets the global variables:\n      LinkedList, FirstNode, FirstEmpty\n    \"\"\""}, {"visible": "    global LinkedList", "tip": ""}, {"visible": "    global FirstNode", "tip": ""}, {"visible": "    global FirstEmpty", "tip": ""}, {"visible": "    FirstNode = NULL_POINTER", "tip": "# The linked list is empty at the start, so there is no first node"}, {"visible": "    FirstEmpty = 0", "tip": "# The first free node will be index 0 (the start of the free list)"}, {"visible": "    LinkedList = []", "tip": "# Create the array of nodes, each node initially stores:\n#   data = -1 (meaning \"no real data stored yet\")\n#   nextPointer = index of next free node (set below)"}, {"visible": "    for i in range(size):", "tip": ""}, {"visible": "        LinkedList.append([-1, NULL_POINTER])", "tip": "# Temporarily set nextPointer to -1, we will fix pointers after"}, {"visible": "    for i in range(size - 1):", "tip": "# Link all nodes into the free list:\n# node 0 points to node 1, node 1 points to node 2, ..., last points to -1"}, {"visible": "        LinkedList[i][1] = i + 1", "tip": "# next free node index"}, {"visible": "    LinkedList[size - 1][1] = NULL_POINTER", "tip": "# The last node in the free list points to -1 to show end of free list"}]}, "linkedFindPseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION linkedFindPseudo(SearchItem) RETURNS INTEGER", "tip": ""}, {"visible": "    CurrentPtr <- StartPointer", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    WHILE CurrentPtr <> NullPointer AND List[CurrentPtr].Data <> SearchItem DO", "tip": ""}, {"visible": "        CurrentPtr <- List[CurrentPtr].Pointer", "tip": ""}, {"visible": "    ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    RETURN CurrentPtr   // returns -1 if not found", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "linkedFindPython": {"kind": "python", "lines": [{"visible": "def linkedFindPython(search_item):", "tip": "    \"\"\"\n    Find the first node containing search_item.\n\n    Returns:\n      index of the node if found\n      -1 if not found\n    \"\"\""}, {"visible": "    global LinkedList", "tip": ""}, {"visible": "    global FirstNode", "tip": ""}, {"visible": "    current_ptr = FirstNode", "tip": "# Start from the first node in the linked list"}, {"visible": "    while current_ptr != NULL_POINTER and LinkedList[current_ptr][0] != search_item:", "tip": "# Keep going until we either reach the end (-1) or find the item"}, {"visible": "        current_ptr = LinkedList[current_ptr][1]", "tip": "# Move to the next node by following the stored pointer"}, {"visible": "    return current_ptr", "tip": "# If found, current_ptr is the node index; if not, it is -1"}]}, "linkedInsertPseudo": {"kind": "pseudo", "lines": [{"visible": "Insertion rule used here: insert at the front.", "tip": ""}, {"visible": "FUNCTION linkedInsertPseudo(NewItem) RETURNS BOOLEAN", "tip": ""}, {"visible": "    IF FreeListPtr = NullPointer THEN", "tip": ""}, {"visible": "        RETURN FALSE", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    NewNodePtr <- FreeListPtr", "tip": ""}, {"visible": "    FreeListPtr <- List[FreeListPtr].Pointer", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    List[NewNodePtr].Data <- NewItem", "tip": ""}, {"visible": "    List[NewNodePtr].Pointer <- StartPointer", "tip": ""}, {"visible": "    StartPointer <- NewNodePtr", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    RETURN TRUE", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "linkedInsertPython": {"kind": "python", "lines": [{"visible": "def linkedInsertPython(new_item):", "tip": "    \"\"\"\n    Insert new_item at the front of the linked list.\n\n    Returns:\n      True  if insertion succeeded\n      False if there is no free node (list is full)\n    \"\"\""}, {"visible": "    global LinkedList", "tip": ""}, {"visible": "    global FirstNode", "tip": ""}, {"visible": "    global FirstEmpty", "tip": ""}, {"visible": "    if FirstEmpty == NULL_POINTER:", "tip": "# If FirstEmpty is -1, the free list is empty, so there is no space"}, {"visible": "        return False", "tip": ""}, {"visible": "    new_ptr = FirstEmpty", "tip": "# Take the first free node from the free list"}, {"visible": "    next_free = LinkedList[new_ptr][1]", "tip": "# Save the next free node index BEFORE we reuse this node"}, {"visible": "    FirstEmpty = next_free", "tip": "# Move the free list head forward"}, {"visible": "    LinkedList[new_ptr][0] = new_item", "tip": "# Store the new data in the node we just took"}, {"visible": "    LinkedList[new_ptr][1] = FirstNode", "tip": "# Make the new node point to the current first node of the list"}, {"visible": "    FirstNode = new_ptr", "tip": "# Update FirstNode so the linked list now starts at the new node"}, {"visible": "    return True", "tip": ""}]}, "linkedDeletePseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION linkedDeletePseudo(DeleteItem) RETURNS BOOLEAN", "tip": ""}, {"visible": "    ThisPtr <- StartPointer", "tip": ""}, {"visible": "    PrevPtr <- NullPointer", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    WHILE ThisPtr <> NullPointer AND List[ThisPtr].Data <> DeleteItem DO", "tip": ""}, {"visible": "        PrevPtr <- ThisPtr", "tip": ""}, {"visible": "        ThisPtr <- List[ThisPtr].Pointer", "tip": ""}, {"visible": "    ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF ThisPtr = NullPointer THEN", "tip": ""}, {"visible": "        RETURN FALSE", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF ThisPtr = StartPointer THEN", "tip": ""}, {"visible": "        StartPointer <- List[StartPointer].Pointer", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "        List[PrevPtr].Pointer <- List[ThisPtr].Pointer", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    List[ThisPtr].Pointer <- FreeListPtr", "tip": ""}, {"visible": "    FreeListPtr <- ThisPtr", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    RETURN TRUE", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "linkedDeletePython": {"kind": "python", "lines": [{"visible": "def linkedDeletePython(item_to_delete):", "tip": "    \"\"\"\n    Delete the first node containing item_to_delete.\n\n    Returns:\n      True  if deletion succeeded\n      False if the item was not found\n    \"\"\""}, {"visible": "    global LinkedList", "tip": ""}, {"visible": "    global FirstNode", "tip": ""}, {"visible": "    global FirstEmpty", "tip": ""}, {"visible": "    this_ptr = FirstNode", "tip": "# Start searching from the first node in the linked list"}, {"visible": "    prev_ptr = NULL_POINTER", "tip": "# prev_ptr tracks the node before this_ptr"}, {"visible": "    while this_ptr != NULL_POINTER and LinkedList[this_ptr][0] != item_to_delete:", "tip": "# Move through the list until we find the item or reach the end"}, {"visible": "        prev_ptr = this_ptr", "tip": "# The current node becomes the previous node"}, {"visible": "        this_ptr = LinkedList[this_ptr][1]", "tip": "# Follow the pointer to move to the next node"}, {"visible": "    if this_ptr == NULL_POINTER:", "tip": "# If this_ptr is -1, we reached the end without finding the item"}, {"visible": "        return False", "tip": ""}, {"visible": "    if this_ptr == FirstNode:", "tip": "# Remove the node from the linked list"}, {"visible": "        FirstNode = LinkedList[FirstNode][1]", "tip": "# Deleting the first node:\n# FirstNode must move to the second node"}, {"visible": "    else:", "tip": ""}, {"visible": "        LinkedList[prev_ptr][1] = LinkedList[this_ptr][1]", "tip": "# Deleting a middle or last node:\n# Make the previous node skip over the deleted node"}, {"visible": "    LinkedList[this_ptr][1] = FirstEmpty", "tip": "# Return the deleted node to the free list\n# Step 1: make the deleted node point to the current first free node"}, {"visible": "    FirstEmpty = this_ptr", "tip": "# Step 2: update the free list head so it becomes the deleted node\n# This means the deleted node is now the first free node available for reuse"}, {"visible": "    LinkedList[this_ptr][0] = -1", "tip": "# Optional: clear the data to show this node is now empty"}, {"visible": "    return True", "tip": ""}]}, "stackInitialisePseudo": {"kind": "pseudo", "lines": [{"visible": "CONSTANT EMPTYSTRING = \"\"", "tip": ""}, {"visible": "CONSTANT NullPointer = -1", "tip": ""}, {"visible": "CONSTANT MaxStackSize = 8", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "DECLARE BaseOfStackPointer : INTEGER", "tip": ""}, {"visible": "DECLARE TopOfStackPointer  : INTEGER", "tip": ""}, {"visible": "DECLARE Stack : ARRAY[0 : MaxStackSize - 1] OF STRING", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "PROCEDURE stackInitialisePseudo", "tip": ""}, {"visible": "    BaseOfStackPointer <- 0", "tip": ""}, {"visible": "    TopOfStackPointer  <- NullPointer", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "stackIsEmptyPseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION stackIsEmptyPseudo RETURNS BOOLEAN", "tip": ""}, {"visible": "    IF TopOfStackPointer = NullPointer THEN", "tip": ""}, {"visible": "        RETURN TRUE", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "        RETURN FALSE", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "stackIsFullPseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION stackIsFullPseudo RETURNS BOOLEAN", "tip": ""}, {"visible": "    IF TopOfStackPointer >= MaxStackSize - 1 THEN", "tip": ""}, {"visible": "        RETURN TRUE", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "        RETURN FALSE", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "stackPushPseudo": {"kind": "pseudo", "lines": [{"visible": "PROCEDURE stackPushPseudo(NewItem)", "tip": ""}, {"visible": "    IF TopOfStackPointer < MaxStackSize - 1 THEN", "tip": ""}, {"visible": "        TopOfStackPointer <- TopOfStackPointer + 1", "tip": ""}, {"visible": "        Stack[TopOfStackPointer] <- NewItem", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "stackPopPseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION stackPopPseudo RETURNS STRING", "tip": ""}, {"visible": "    DECLARE Item : STRING", "tip": ""}, {"visible": "    Item <- EMPTYSTRING", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF TopOfStackPointer > NullPointer THEN", "tip": ""}, {"visible": "        Item <- Stack[TopOfStackPointer]", "tip": ""}, {"visible": "        TopOfStackPointer <- TopOfStackPointer - 1", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    RETURN Item", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "stackInitialisePython": {"kind": "python", "lines": [{"visible": "MAX_STACK_SIZE = 8", "tip": ""}, {"visible": "EMPTY_STRING = \"\"", "tip": ""}, {"visible": "Stack = [EMPTY_STRING] * (MAX_STACK_SIZE + 1)", "tip": ""}, {"visible": "BasePointer = 1", "tip": ""}, {"visible": "TopPointer = 0", "tip": ""}, {"visible": "def stackInitialisePython():", "tip": "    \"\"\"\n    Set the stack to an empty state.\n    \"\"\""}, {"visible": "    global Stack", "tip": ""}, {"visible": "    global BasePointer", "tip": ""}, {"visible": "    global TopPointer", "tip": ""}, {"visible": "    BasePointer = 1", "tip": ""}, {"visible": "    TopPointer = 0", "tip": ""}, {"visible": "    for i in range(1, MAX_STACK_SIZE + 1):", "tip": ""}, {"visible": "        Stack[i] = EMPTY_STRING", "tip": ""}]}, "stackIsEmptyPython": {"kind": "python", "lines": [{"visible": "def stackIsEmptyPython():", "tip": "    \"\"\"\n    Return True if the stack is empty, otherwise False.\n    \"\"\""}, {"visible": "    global BasePointer", "tip": ""}, {"visible": "    global TopPointer", "tip": ""}, {"visible": "    return TopPointer < BasePointer", "tip": ""}]}, "stackIsFullPython": {"kind": "python", "lines": [{"visible": "def stackIsFullPython():", "tip": "    \"\"\"\n    Return True if the stack is full, otherwise False.\n    \"\"\""}, {"visible": "    global TopPointer", "tip": ""}, {"visible": "    return TopPointer == MAX_STACK_SIZE", "tip": ""}]}, "stackPushPython": {"kind": "python", "lines": [{"visible": "def stackPushPython(new_item):", "tip": "    \"\"\"\n    Add new_item to the top of the stack.\n    Return True if the push succeeds, otherwise False.\n    \"\"\""}, {"visible": "    global Stack", "tip": ""}, {"visible": "    global TopPointer", "tip": ""}, {"visible": "    if stackIsFullPython():", "tip": ""}, {"visible": "        return False", "tip": ""}, {"visible": "    TopPointer = TopPointer + 1", "tip": ""}, {"visible": "    Stack[TopPointer] = new_item", "tip": ""}, {"visible": "    return True", "tip": ""}]}, "stackPopPython": {"kind": "python", "lines": [{"visible": "def stackPopPython():", "tip": "    \"\"\"\n    Remove and return the top item from the stack.\n    Return EMPTY_STRING if the stack is empty.\n    \"\"\""}, {"visible": "    global Stack", "tip": ""}, {"visible": "    global TopPointer", "tip": ""}, {"visible": "    if stackIsEmptyPython():", "tip": ""}, {"visible": "        return EMPTY_STRING", "tip": ""}, {"visible": "    item = Stack[TopPointer]", "tip": ""}, {"visible": "    Stack[TopPointer] = EMPTY_STRING", "tip": ""}, {"visible": "    TopPointer = TopPointer - 1", "tip": ""}, {"visible": "    return item", "tip": ""}]}, "queueInitialisePseudo": {"kind": "pseudo", "lines": [{"visible": "CONSTANT EMPTYSTRING = \"\"", "tip": "// NullPointer should be set to -1 if using array element with index 0"}, {"visible": "CONSTANT NullPointer = -1", "tip": ""}, {"visible": "CONSTANT MaxQueueSize = 8", "tip": ""}, {"visible": "DECLARE FrontOfQueuePointer : INTEGER", "tip": ""}, {"visible": "DECLARE EndOfQueuePointer : INTEGER", "tip": ""}, {"visible": "DECLARE NumberInQueue : INTEGER", "tip": ""}, {"visible": "DECLARE Queue : ARRAY[0 : MaxQueueSize – 1] OF STRING", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "PROCEDURE InitialiseQueue", "tip": ""}, {"visible": "  FrontOfQueuePointer ← NullPointer // set front of queue pointer", "tip": ""}, {"visible": "  EndOfQueuePointer ← NullPointer   // set end of queue pointer", "tip": ""}, {"visible": "  NumberInQueue ← 0                // no elements in queue", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "queueInitialisePython": {"kind": "python", "lines": [{"visible": "MAX_QUEUE_SIZE = 20", "tip": "Fixed-size circular queue using an array and three control variables.\n# Maximum number of items the queue can store"}, {"visible": "Queue = [0] * MAX_QUEUE_SIZE", "tip": "# The array that stores the queue items"}, {"visible": "HeadPointer = -1", "tip": "# Index of the front item; -1 means the queue is empty"}, {"visible": "TailPointer = -1", "tip": "# Index of the last item added; -1 means the queue is empty"}, {"visible": "NumberItems = 0", "tip": "# How many items are currently in the queue"}]}, "queueEnqueuePseudo": {"kind": "pseudo", "lines": [{"visible": "PROCEDURE AddToQueue(NewItem)", "tip": ""}, {"visible": "  IF NumberInQueue < MaxQueueSize", "tip": ""}, {"visible": "  THEN // there is space in the queue", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    EndOfQueuePointer ← EndOfQueuePointer + 1", "tip": "// increment end of queue pointer"}, {"visible": "", "tip": ""}, {"visible": "    IF EndOfQueuePointer > MaxQueueSize – 1", "tip": "// check for wrap-round"}, {"visible": "    THEN // wrap to beginning of array", "tip": ""}, {"visible": "      EndOfQueuePointer ← 0", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    Queue[EndOfQueuePointer] ← NewItem", "tip": "// add item to end of queue"}, {"visible": "", "tip": ""}, {"visible": "    NumberInQueue ← NumberInQueue + 1", "tip": "// increment counter"}, {"visible": "", "tip": ""}, {"visible": "  ENDIF", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "queueEnqueuePython": {"kind": "python", "lines": [{"visible": "def queueEnqueuePython(input_data):", "tip": "    \"\"\"\n    Adds one item to the rear of the circular queue.\n\n    Returns:\n        True  if the item was added\n        False if the queue is full\n    \"\"\""}, {"visible": "    global Queue, HeadPointer, TailPointer, NumberItems", "tip": ""}, {"visible": "    if NumberItems >= MAX_QUEUE_SIZE:", "tip": "# 1) Check for overflow (queue full)"}, {"visible": "        return False", "tip": ""}, {"visible": "    if TailPointer == -1:", "tip": "# 2) If the queue is empty, the first item sets both head and tail"}, {"visible": "        TailPointer = 0", "tip": "# Tail now points to index 0"}, {"visible": "        HeadPointer = 0", "tip": "# Head also points to index 0"}, {"visible": "        Queue[TailPointer] = input_data", "tip": "# Store the first item"}, {"visible": "    else:", "tip": ""}, {"visible": "        if TailPointer >= MAX_QUEUE_SIZE - 1:", "tip": "# 3) Move TailPointer forward (wrap-round if at the end)"}, {"visible": "            TailPointer = 0", "tip": "# Wrap to the start of the array"}, {"visible": "        else:", "tip": ""}, {"visible": "            TailPointer += 1", "tip": "# Move to the next index"}, {"visible": "        Queue[TailPointer] = input_data", "tip": "# 4) Store the new item at the new tail position"}, {"visible": "    NumberItems += 1", "tip": "# 5) Increase the item count because one item was added"}, {"visible": "    return True", "tip": ""}]}, "queueDequeuePseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION RemoveFromQueue()", "tip": ""}, {"visible": "  DECLARE Item : STRING", "tip": ""}, {"visible": "  Item ← EMPTYSTRING", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "  IF NumberInQueue > 0", "tip": ""}, {"visible": "  THEN // there is at least one item in the queue", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    Item ← Queue[FrontOfQueuePointer]", "tip": "// remove item from the front of the queue"}, {"visible": "    NumberInQueue ← NumberInQueue – 1", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF NumberInQueue = 0", "tip": ""}, {"visible": "    THEN // if queue empty, reset pointers", "tip": ""}, {"visible": "      CALL InitialiseQueue", "tip": ""}, {"visible": "    ELSE", "tip": ""}, {"visible": "      FrontOfQueuePointer ← FrontOfQueuePointer + 1", "tip": "// increment front of queue pointer"}, {"visible": "", "tip": ""}, {"visible": "      IF FrontOfQueuePointer > MaxQueueSize – 1", "tip": "// check for wrap-round"}, {"visible": "      THEN // wrap to beginning of array", "tip": ""}, {"visible": "        FrontOfQueuePointer ← 0", "tip": ""}, {"visible": "      ENDIF", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "  ENDIF", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "  RETURN Item", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "queueDequeuePython": {"kind": "python", "lines": [{"visible": "def queueDequeuePython():", "tip": "    \"\"\"\n    Removes one item from the front of the circular queue.\n\n    Returns:\n        The removed value.\n        If the queue is empty, returns -1 (sentinel value).\n    \"\"\""}, {"visible": "    global Queue, HeadPointer, TailPointer, NumberItems", "tip": ""}, {"visible": "    if NumberItems <= 0:", "tip": "# 1) Check for underflow (queue empty)"}, {"visible": "        return -1", "tip": ""}, {"visible": "    return_value = Queue[HeadPointer]", "tip": "# 2) Read the item at the head (front)"}, {"visible": "    HeadPointer += 1", "tip": "# 3) Move HeadPointer forward (wrap-round if needed)"}, {"visible": "    if HeadPointer >= MAX_QUEUE_SIZE:", "tip": ""}, {"visible": "        HeadPointer = 0", "tip": ""}, {"visible": "    NumberItems -= 1", "tip": "# 4) Decrease the item count because one item was removed"}, {"visible": "    if NumberItems == 0:", "tip": "# 5) If the queue becomes empty, reset both pointers"}, {"visible": "        HeadPointer = -1", "tip": ""}, {"visible": "        TailPointer = -1", "tip": ""}, {"visible": "    return return_value", "tip": "# 6) Return the removed item"}]}, "binaryTreeInitialisePseudo": {"kind": "pseudo", "lines": [{"visible": "CONSTANT NullPointer = -1", "tip": "// NullPointer should be set to -1 if using array element with index 0"}, {"visible": "", "tip": ""}, {"visible": "TYPE TreeNode", "tip": "// Declare record type to store data and pointers"}, {"visible": "  DECLARE Data : STRING", "tip": ""}, {"visible": "  DECLARE LeftPointer : INTEGER", "tip": ""}, {"visible": "  DECLARE RightPointer : INTEGER", "tip": ""}, {"visible": "ENDTYPE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "DECLARE RootPointer : INTEGER", "tip": ""}, {"visible": "DECLARE FreePtr : INTEGER", "tip": ""}, {"visible": "DECLARE Tree : ARRAY[0 : 6] OF TreeNode", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "PROCEDURE InitialiseTree", "tip": ""}, {"visible": "  RootPointer ← NullPointer // set start pointer", "tip": ""}, {"visible": "  FreePtr ← 0 // set starting position of free list", "tip": ""}, {"visible": "  FOR Index ← 0 TO 5 // link all nodes to make free list", "tip": ""}, {"visible": "    Tree[Index].LeftPointer ← Index + 1", "tip": ""}, {"visible": "  NEXT Index", "tip": ""}, {"visible": "  Tree[6].LeftPointer ← NullPointer // last node of free list", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "binaryTreeInsertPseudo": {"kind": "pseudo", "lines": [{"visible": "PROCEDURE InsertNode(NewItem)", "tip": ""}, {"visible": "  IF FreePtr <> NullPointer", "tip": ""}, {"visible": "  THEN // there is space in the array", "tip": ""}, {"visible": "    NewNodePtr ← FreePtr", "tip": "// take node from free list, store data item, set null pointers"}, {"visible": "    FreePtr ← Tree[FreePtr].LeftPointer", "tip": ""}, {"visible": "    Tree[NewNodePtr].Data ← NewItem", "tip": ""}, {"visible": "    Tree[NewNodePtr].LeftPointer ← NullPointer", "tip": ""}, {"visible": "    Tree[NewNodePtr].RightPointer ← NullPointer", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "    IF RootPointer = NullPointer", "tip": "// check if empty tree"}, {"visible": "    THEN // insert new node at root", "tip": ""}, {"visible": "      RootPointer ← NewNodePtr", "tip": ""}, {"visible": "    ELSE // find insertion point", "tip": ""}, {"visible": "      ThisNodePtr ← RootPointer // start at the root of the tree", "tip": ""}, {"visible": "      WHILE ThisNodePtr <> NullPointer DO // while not a leaf node", "tip": ""}, {"visible": "        PreviousNodePtr ← ThisNodePtr // remember this node", "tip": ""}, {"visible": "        IF Tree[ThisNodePtr].Data > NewItem", "tip": ""}, {"visible": "        THEN // follow left pointer", "tip": ""}, {"visible": "          TurnedLeft ← TRUE", "tip": ""}, {"visible": "          ThisNodePtr ← Tree[ThisNodePtr].LeftPointer", "tip": ""}, {"visible": "        ELSE // follow right pointer", "tip": ""}, {"visible": "          TurnedLeft ← FALSE", "tip": ""}, {"visible": "          ThisNodePtr ← Tree[ThisNodePtr].RightPointer", "tip": ""}, {"visible": "        ENDIF", "tip": ""}, {"visible": "      ENDWHILE", "tip": ""}, {"visible": "", "tip": ""}, {"visible": "      IF TurnedLeft = TRUE", "tip": ""}, {"visible": "      THEN", "tip": ""}, {"visible": "        Tree[PreviousNodePtr].LeftPointer ← NewNodePtr", "tip": ""}, {"visible": "      ELSE", "tip": ""}, {"visible": "        Tree[PreviousNodePtr].RightPointer ← NewNodePtr", "tip": ""}, {"visible": "      ENDIF", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "  ENDIF", "tip": ""}, {"visible": "ENDPROCEDURE", "tip": ""}]}, "binaryTreeFindPseudo": {"kind": "pseudo", "lines": [{"visible": "FUNCTION FindNode(SearchItem) RETURNS INTEGER // returns pointer to node", "tip": ""}, {"visible": "  ThisNodePtr ← RootPointer // start at the root of the tree", "tip": ""}, {"visible": "  WHILE ThisNodePtr <> NullPointer // while a pointer to follow", "tip": ""}, {"visible": "    AND Tree[ThisNodePtr].Data <> SearchItem DO // and search item not found", "tip": ""}, {"visible": "    IF Tree[ThisNodePtr].Data > SearchItem", "tip": ""}, {"visible": "    THEN // follow left pointer", "tip": ""}, {"visible": "      ThisNodePtr ← Tree[ThisNodePtr].LeftPointer", "tip": ""}, {"visible": "    ELSE // follow right pointer", "tip": ""}, {"visible": "      ThisNodePtr ← Tree[ThisNodePtr].RightPointer", "tip": ""}, {"visible": "    ENDIF", "tip": ""}, {"visible": "  ENDWHILE", "tip": ""}, {"visible": "  RETURN ThisNodePtr // will return null pointer if search item not found", "tip": ""}, {"visible": "ENDFUNCTION", "tip": ""}]}, "binaryTreeInitialisePython": {"kind": "python", "lines": [{"visible": "def binaryTreeInitialisePython(max_nodes: int = 20):", "tip": "    \"\"\"\n    Create an empty binary search tree stored in an array.\n\n    Each node is stored as:\n        ArrayNodes[index] = [LeftPointer, Data, RightPointer]\n\n    Pointer value -1 means \"null pointer\" (no child).\n    RootPointer is the index of the root node, or -1 if the tree is empty.\n    FreeNode is the index of the next free row in ArrayNodes.\n    \"\"\""}, {"visible": "    ArrayNodes = [[-1, -1, -1] for _ in range(max_nodes)]", "tip": "# Create the array that will hold all nodes (fixed size)\n# [-1, -1, -1] means unused node"}, {"visible": "    RootPointer = -1", "tip": "# Start with an empty tree, so there is no root yet"}, {"visible": "    FreeNode = 0", "tip": "# The first free node is at index 0"}, {"visible": "    return ArrayNodes, RootPointer, FreeNode", "tip": "# Return all structures so they can be used by insert/search routines"}]}, "binaryTreeInsertPython": {"kind": "python", "lines": [{"visible": "def binaryTreeInsertPython(ArrayNodes, RootPointer: int, FreeNode: int, NodeData: int):", "tip": "    \"\"\"\n    Insert one integer value into the binary search tree.\n\n    Returns:\n        ArrayNodes, RootPointer, FreeNode, Success\n    where Success is True if insertion happened, False if the array is full.\n    \"\"\""}, {"visible": "    max_nodes = len(ArrayNodes)", "tip": "# maximum number of nodes that can be stored"}, {"visible": "    if FreeNode >= max_nodes:", "tip": "# Check if there is space to insert a new node"}, {"visible": "        return ArrayNodes, RootPointer, FreeNode, False", "tip": "# no space"}, {"visible": "    ArrayNodes[FreeNode][0] = -1", "tip": "# Initialise the new node at index FreeNode\n# LeftPointer: no left child yet"}, {"visible": "    ArrayNodes[FreeNode][1] = NodeData", "tip": "# Data: store the value being inserted"}, {"visible": "    ArrayNodes[FreeNode][2] = -1", "tip": "# RightPointer: no right child yet"}, {"visible": "    if RootPointer == -1:", "tip": "# Case 1: tree is empty, so the new node becomes the root"}, {"visible": "        RootPointer = FreeNode", "tip": ""}, {"visible": "    else:", "tip": ""}, {"visible": "        Placed = False", "tip": "# Case 2: tree is not empty, so find where to attach the new node\n# becomes True when we attach the new node"}, {"visible": "        CurrentNode = RootPointer", "tip": "# start at the root"}, {"visible": "        while not Placed:", "tip": "# Repeat until we find a missing child pointer (-1) where we can attach"}, {"visible": "            if NodeData < ArrayNodes[CurrentNode][1]:", "tip": "# If new value is smaller, move left"}, {"visible": "                if ArrayNodes[CurrentNode][0] == -1:", "tip": "# If there is no left child, attach the new node here"}, {"visible": "                    ArrayNodes[CurrentNode][0] = FreeNode", "tip": ""}, {"visible": "                    Placed = True", "tip": ""}, {"visible": "                else:", "tip": ""}, {"visible": "                    CurrentNode = ArrayNodes[CurrentNode][0]", "tip": "# Follow the left pointer and continue searching for a place"}, {"visible": "            else:", "tip": ""}, {"visible": "                if ArrayNodes[CurrentNode][2] == -1:", "tip": "# Otherwise (equal or larger), move right\n# If there is no right child, attach the new node here"}, {"visible": "                    ArrayNodes[CurrentNode][2] = FreeNode", "tip": ""}, {"visible": "                    Placed = True", "tip": ""}, {"visible": "                else:", "tip": ""}, {"visible": "                    CurrentNode = ArrayNodes[CurrentNode][2]", "tip": "# Follow the right pointer and continue searching for a place"}, {"visible": "    FreeNode = FreeNode + 1", "tip": "# Move FreeNode to the next free position for the next insertion"}, {"visible": "    return ArrayNodes, RootPointer, FreeNode, True", "tip": "# Insertion succeeded"}]}, "binaryTreeFindPython": {"kind": "python", "lines": [{"visible": "def binaryTreeFindPython(ArrayNodes, RootPointer: int, SearchItem: int) -> int:", "tip": "    \"\"\"\n    Search for SearchItem in the binary search tree.\n\n    Returns:\n        - the array index of the node containing SearchItem, if found\n        - -1 if SearchItem is not in the tree\n    \"\"\""}, {"visible": "    CurrentNode = RootPointer", "tip": "# Start searching from the root node"}, {"visible": "    while CurrentNode != -1 and ArrayNodes[CurrentNode][1] != SearchItem:", "tip": "# Keep following pointers while:\n#   - we have not fallen off the tree (CurrentNode != -1)\n#   - and we have not found the value yet"}, {"visible": "        if SearchItem < ArrayNodes[CurrentNode][1]:", "tip": "# Decide which branch to follow based on the ordered-tree rule"}, {"visible": "            CurrentNode = ArrayNodes[CurrentNode][0]", "tip": "# Move to the left child"}, {"visible": "        else:", "tip": ""}, {"visible": "            CurrentNode = ArrayNodes[CurrentNode][2]", "tip": "# Move to the right child"}, {"visible": "    return CurrentNode", "tip": "# Either CurrentNode is the index where the value was found,\n# or it is -1 (null pointer) meaning \"not found\""}]}};
  var annexTitles = {"LinearSearchPseudo": "1) Linear search (algorithm idea)", "LinearSearchPython": "1) Linear search (algorithm idea)", "BinarySearchPseudo": "2) Binary search (algorithm idea)", "BinarySearchPython": "2) Binary search (algorithm idea)", "InsertionSortPseudo": "1) Insertion sort (algorithm idea)", "InsertionSortPython": "1) Insertion sort (algorithm idea)", "BubbleSortPseudo": "2) Bubble sort (algorithm idea)", "BubbleSortPython": "2) Bubble sort (algorithm idea)", "linkedInitialisePseudo": "Annex: linkedInitialisePseudo", "linkedInitialisePython": "Annex: linkedInitialisePython", "linkedFindPseudo": "Annex: linkedFindPseudo", "linkedFindPython": "Annex: linkedFindPython", "linkedInsertPseudo": "Annex: linkedInsertPseudo", "linkedInsertPython": "Annex: linkedInsertPython", "linkedDeletePseudo": "Annex: linkedDeletePseudo", "linkedDeletePython": "Annex: linkedDeletePython", "stackInitialisePseudo": "Annex: stackInitialisePseudo", "stackIsEmptyPseudo": "Annex: stackIsEmptyPseudo", "stackIsFullPseudo": "Annex: stackIsFullPseudo", "stackPushPseudo": "Annex: stackPushPseudo", "stackPopPseudo": "Annex: stackPopPseudo", "stackInitialisePython": "Annex: stackInitialisePython", "stackIsEmptyPython": "Annex: stackIsEmptyPython", "stackIsFullPython": "Annex: stackIsFullPython", "stackPushPython": "Annex: stackPushPython", "stackPopPython": "Annex: stackPopPython", "queueInitialisePseudo": "Algorithm 1: Initialise a queue", "queueInitialisePython": "Annex: queueInitialisePython", "queueEnqueuePseudo": "Algorithm 2: Add an item (enQueue)", "queueEnqueuePython": "Annex: queueEnqueuePython", "queueDequeuePseudo": "Algorithm 3: Remove an item (deQueue)", "queueDequeuePython": "Annex: queueDequeuePython", "binaryTreeInitialisePseudo": "Annex: binaryTreeInitialisePseudo", "binaryTreeInsertPseudo": "Annex: binaryTreeInsertPseudo", "binaryTreeFindPseudo": "Annex: binaryTreeFindPseudo", "binaryTreeInitialisePython": "Annex: binaryTreeInitialisePython", "binaryTreeInsertPython": "Annex: binaryTreeInsertPython", "binaryTreeFindPython": "Annex: binaryTreeFindPython"};
  function qs(id){ return document.getElementById(id); }
  function buildCodeHtml(aid){
    var item = annexData[aid];
    if(!item) return null;
    var kind = item.kind;
    var wrap = document.createElement("div");
    wrap.className = "code-wrap " + kind;
    (item.lines || []).forEach(function(ln){
      var div = document.createElement("div");
      div.className = "code-line";
      div.textContent = (ln.visible || "");
      if(ln.tip) div.setAttribute("data-tip", ln.tip);
      wrap.appendChild(div);
    });
    return wrap;
  }
  function openModal(aid){
    var bd = qs("annexModalBackdrop");
    var title = qs("annexModalTitle");
    var codeWrap = qs("annexModalCodeWrap");
    var tip = qs("modalTipPanel");
    if(!bd || !title || !codeWrap || !tip) return false;
    codeWrap.innerHTML = "";
    tip.textContent = "";
    tip.classList.add("visible");
    title.textContent = (annexTitles[aid] || ("Annex: " + aid));
    var idLine = document.createElement("div");
    idLine.className = "code-id";
    idLine.textContent = "Annex: " + aid;
    codeWrap.appendChild(idLine);
    var code = buildCodeHtml(aid);
    if(!code) return false;
    codeWrap.appendChild(code);
    code.querySelectorAll(".code-line[data-tip]").forEach(function(line){
      line.addEventListener("click", function(){ tip.textContent = line.getAttribute("data-tip") || ""; });
    });
    bd.classList.add("open");
    bd.setAttribute("aria-hidden","false");
    document.body.style.overflow = "hidden";
    return true;
  }
  function closeModal(){
    var bd = qs("annexModalBackdrop");
    var codeWrap = qs("annexModalCodeWrap");
    var tip = qs("modalTipPanel");
    if(!bd) return;
    bd.classList.remove("open");
    bd.setAttribute("aria-hidden","true");
    document.body.style.overflow = "";
    if(codeWrap) codeWrap.innerHTML = "";
    if(tip) tip.textContent = "";
  }
  document.addEventListener("click", function(e){
    var a = e.target.closest && e.target.closest("a.annex-link");
    if(!a) return;
    var aid = a.getAttribute("data-annex");
    if(!aid) return;
    var modal = qs("annexModalBackdrop");
    if(modal){ e.preventDefault(); openModal(aid); }
  });
  var closeBtn = qs("annexModalClose");
  if(closeBtn) closeBtn.addEventListener("click", closeModal);
  var bd = qs("annexModalBackdrop");
  if(bd) bd.addEventListener("click", function(e){ if(e.target === bd) closeModal(); });
  document.addEventListener("keydown", function(e){ if(e.key === "Escape") closeModal(); });
  var tipPanel = qs("tipPanel");
  function setTip(text){
    if(!tipPanel) return;
    if(!text) { tipPanel.classList.remove("visible"); tipPanel.textContent=""; tipPanel.setAttribute("aria-hidden","true"); return; }
    tipPanel.textContent = text;
    tipPanel.classList.add("visible");
    tipPanel.setAttribute("aria-hidden","false");
  }
  document.querySelectorAll(".code-line[data-tip]").forEach(function(line){ line.addEventListener("click", function(){ setTip(line.getAttribute("data-tip") || ""); }); });
})();
