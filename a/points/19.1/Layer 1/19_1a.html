<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>19.1a</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <h1 class="main-title">19.1 Algorithms</h1>
      <div class="sub-title">Theory notes prepared by Dr. Hamdeni</div>
      <nav class="nav"><a class='nav-link active' href='19_1a.html'>19.1a</a>
<a class='nav-link' href='19_1b.html'>19.1b</a>
<a class='nav-link' href='19_1c.html'>19.1c</a>
<a class='nav-link' href='19_1d.html'>19.1d</a>
<a class='nav-link' href='19_1e.html'>19.1e</a>
<a class='nav-link' href='annex_19_1.html'>Annex</a></nav>
    </div>
  </header>

  <main class="layout">
    <aside class="sidebar"><div class='sommaire'><div class='sommaire-title'>Sommaire</div><ul class='sommaire-list'><li class='sommaire-item'><a href='#sec_1_Linear_search_algorithm_idea'>1) Linear search (algorithm idea)</a></li><li class='sommaire-item'><a href='#sec_2_Binary_search_algorithm_idea'>2) Binary search (algorithm idea)</a></li><li class='sommaire-item'><a href='#sec_3_Conditions_necessary_for_using_a_binary_search'>3) Conditions necessary for using a binary search</a></li><li class='sommaire-item'><a href='#sec_4_How_binary_search_performance_varies_with_the_number_of_data_items'>4) How binary-search performance varies with the number of data items</a></li><li class='sommaire-subsub'><a href='#sec_4_How_binary_search_performance_varies_with_the_number_of_data_items__A_Example_1_search_for_1024_in_a_sorted_list_of_1024_items_1_1024'>A. Example 1: search for 1024 in a sorted list of 1024 items (1..1024)</a></li><li class='sommaire-subsub'><a href='#sec_4_How_binary_search_performance_varies_with_the_number_of_data_items__B_Example_2_search_for_W_in_the_sorted_letters_A_Z_26_letters'>B. Example 2: search for W in the sorted letters A..Z (26 letters)</a></li></ul></div></aside>

    <section class="content">
      <section class="syllabus-card">
        <div class="hero-title"><div class='hero-code'>19.1a:</div><div class='hero-rest'>Show understanding of linear and binary searching methods:</div></div>
        <div class="targets-wrap"><ul class='targets level-0'>
<li>Write an algorithm to implement a linear search</li>
<li>Write an algorithm to implement a binary search</li>
<li>The conditions necessary for the use of a binary search</li>
<li>How the performance of a binary search varies according to the number of data items</li>
</ul></div>
      </section>
      
<section class="note-card" id="sec_1_Linear_search_algorithm_idea">
  <h2 class="subheading">1) Linear search (algorithm idea)</h2>
  <div class="note-body"><ul class='note-list level-0'>
<li>A linear search checks each element of an array in order, starting from the lower bound and moving to the upper bound, until the required item is found or the upper bound is reached.</li>
<li>This method can be used even when items are stored in any order (no sorting requirement).</li>
<li>As the size of the list increases, the average time to retrieve an item increases correspondingly.</li>

</ul>
<p class='note-paragraph'>See <a class="annex-link" href="annex_19_1.html#LinearSearchPseudo" data-annex="LinearSearchPseudo">Annex: LinearSearchPseudo</a> and <a class="annex-link" href="annex_19_1.html#LinearSearchPython" data-annex="LinearSearchPython">Annex: LinearSearchPython</a>.</p></div>
</section>


<section class="note-card" id="sec_2_Binary_search_algorithm_idea">
  <h2 class="subheading">2) Binary search (algorithm idea)</h2>
  <div class="note-body"><ul class='note-list level-0'>
<li>Binary search assumes an ordered list and works by repeatedly checking the middle item and discarding the half that cannot contain the search item.</li>
<li>The binary search pseudocode uses two boundaries (First and Last) to define the current search area; each iteration recomputes Middle and updates one boundary to keep only the relevant half.</li>
</ul>
<p class='note-paragraph'>If there is no search area left, the search fails (tested by First &gt;= Last).</p>
<p class='note-paragraph'>See <a class="annex-link" href="annex_19_1.html#BinarySearchPseudo" data-annex="BinarySearchPseudo">Annex: BinarySearchPseudo</a> and <a class="annex-link" href="annex_19_1.html#BinarySearchPython" data-annex="BinarySearchPython">Annex: BinarySearchPython</a>.</p></div>
</section>

<section class="note-card" id="sec_3_Conditions_necessary_for_using_a_binary_search">
  <h2 class="subheading">3) Conditions necessary for using a binary search</h2>
  <div class="note-body"><ul class='note-list level-0'>
<li>If the list is unordered, use linear search. If the list is ordered, binary search can be used.</li>
<li>The list is assumed sorted in ascending order and stored in a 1D array (indexable structure), which enables selecting and testing the middle element.</li>
<li>Binary search is more efficient than linear search when the list is already sorted.</li>
<li>See <a class="annex-link" href="annex_19_1.html#BinarySearchPseudo" data-annex="BinarySearchPseudo">Annex: BinarySearchPseudo</a> for how ordering and boundaries are used in the algorithm.</li>
</ul></div>
</section>

<section class="note-card" id="sec_4_How_binary_search_performance_varies_with_the_number_of_data_items">
  <h2 class="subheading">4) How binary-search performance varies with the number of data items</h2>
  <div class="note-body"><ul class='note-list level-0'>
<li>Binary search typically uses far fewer comparisons than linear search because it discards half of the list that cannot contain the required item at each step.</li>
</ul>
<div class="example-box"><a id='sec_4_How_binary_search_performance_varies_with_the_number_of_data_items__A_Example_1_search_for_1024_in_a_sorted_list_of_1024_items_1_1024'></a><h3 class='subsub-heading level3'>A. Example 1: search for 1024 in a sorted list of 1024 items (1..1024)</h3>
<ul class='note-list level-0'>
<li>Linear search (from start): compares 1, 2, 3, …, 1024 → 1024 comparisons</li>
<li>Binary search: compares middle items 512, 768, 896, 960, 992, 1008, 1016, 1020, 1022, 1023, 1024 → 11 comparisons</li>
</ul></div>
<div class="example-box"><a id='sec_4_How_binary_search_performance_varies_with_the_number_of_data_items__B_Example_2_search_for_W_in_the_sorted_letters_A_Z_26_letters'></a><h3 class='subsub-heading level3'>B. Example 2: search for W in the sorted letters A..Z (26 letters)</h3>
<ul class='note-list level-0'>
<li>Linear search (from A): W is the 23rd letter → 23 comparisons</li>
<li>Binary search: compares M, then T, then W → 3 comparisons</li>
<li>See <a class="annex-link" href="annex_19_1.html#BinarySearchPython" data-annex="BinarySearchPython">Annex: BinarySearchPython</a> for a direct implementation that performs this “halve the search area” process.</li>
</ul></div></div>
</section>

    </section>
  </main>

  <div class="modal-backdrop" id="annexModalBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Annex code">
    <div class="modal-header">
      <div class="modal-title" id="annexModalTitle"></div>
      <div class="modal-subtitle" id="annexModalSubtitle"></div>
      <button class="modal-close" id="annexModalClose" type="button">Close</button>
    </div>
    <div class="modal-body">
      <div class="modal-codewrap" id="annexModalCodeWrap"></div>
      <div class="tip-panel visible" id="modalTipPanel" aria-hidden="false"></div>
    </div>
  </div>
</div>
  <script src="script.js"></script>
</body>
</html>
