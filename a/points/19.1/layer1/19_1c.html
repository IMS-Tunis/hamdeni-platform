<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>19.1c ADT implementation</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="platform-header">
    <div class="platform-header-left">
      <a href="../../../dashboard.html">
        <img src="/images/maarifLOGO.png" class="logo" id="maarif-logo" alt="Maarif logo">
      </a>
    </div>
    <div class="platform-header-center">
      <h1>Layer 1: Theoretical Foundation</h1>
      <div class="info-line">
        <span id="point-title"></span>
        <span id="student-name"></span>
        <span id="platform-name"></span>
      </div>
    </div>
    <div class="platform-header-right" style="text-align:right;">
      <img src="/images/cambridge.png" class="logo" alt="Cambridge logo">
    </div>
  </header>
  <header class="header">
    <div class="header-inner">
      <div class="header-top">
        <div class="layer-menu" aria-label="Layer navigation">
          <div class="layer-menu-links">
            <a class="layer-link" href="../layer2.html"><span class="layer-number">2</span> Layer 2</a>
            <a class="layer-link" href="../layer3.html"><span class="layer-number">3</span> Layer 3</a>
            <a class="layer-link" href="../layer4.html"><span class="layer-number">4</span> Layer 4</a>
          </div>
        </div>
        <div class="header-text">
          <div class="header-title-row">
            <h1 class="main-title">19.1 Algorithms</h1>
            <button class="syllabus-button" type="button" data-syllabus-trigger="true" aria-haspopup="dialog" aria-controls="syllabus-modal" aria-label="Syllabus">
              <img class="syllabus-icon" src="syllabus 19.1.png" alt="Syllabus">
            </button>
          </div>
          <div class="sub-title">Theory notes prepared by Dr. Hamdeni</div>
        </div>
      </div>
      <nav class="nav"><a class='nav-link' href='19_1a.html'>19.1a Searching</a>
<a class='nav-link' href='19_1b.html'>19.1b Sorting</a>
<a class='nav-link active' href='19_1c.html'>19.1c ADT implementation</a>
<a class='nav-link' href='19_1d.html'>19.1d ADT from ADT</a>
<a class='nav-link' href='19_1e.html'>19.1e Complexity</a>
<a class='nav-link' href='annex_19_1.html'>Annex</a></nav>
    </div>
  </header>
  <div class="syllabus-modal" id="syllabus-modal" role="dialog" aria-modal="true" aria-labelledby="syllabus-title">
    <div class="syllabus-modal-content">
      <button class="syllabus-close" type="button" id="close-syllabus">Close ✕</button>
      <h2 id="syllabus-title" style="margin-top: 0; color: #003366;">Syllabus Points</h2>
      <img src="syllabus 19.1.png" alt="Syllabus points for this page">
    </div>
  </div>

  <main class="layout">
    <aside class="sidebar"><div class='sommaire'><div class='sommaire-title'>Sommaire</div><ul class='sommaire-list'><li class='sommaire-item'><a href='#sec_1_Linked_List'>1) Linked List</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__What_a_linked_list_node_stores'>What a linked list node stores</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__Array_based_linked_list'>Array based linked list</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__The_free_list_how_unused_nodes_are_tracked'>The free list (how unused nodes are tracked)</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__Algorithm_1_Find_search_in_a_linked_list'>Algorithm 1: Find (search) in a linked list</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__Algorithm_2_Insertion_of_a_new_node'>Algorithm 2: Insertion of a new node</a></li><li class='sommaire-subsub'><a href='#sec_1_Linked_List__Algorithm_3_Delete_remove_one_item'>Algorithm 3: Delete (remove one item)</a></li><li class='sommaire-item'><a href='#sec_2_Stack'>2) Stack</a></li><li class='sommaire-subsub'><a href='#sec_2_Stack__Algorithm_0_Initialise_the_stack'>Algorithm 0: Initialise the stack</a></li><li class='sommaire-subsub'><a href='#sec_2_Stack__Algorithm_1_Check_if_the_stack_is_empty'>Algorithm 1: Check if the stack is empty</a></li><li class='sommaire-subsub'><a href='#sec_2_Stack__Algorithm_2_Check_if_the_stack_is_full'>Algorithm 2: Check if the stack is full</a></li><li class='sommaire-subsub'><a href='#sec_2_Stack__Algorithm_3_Push'>Algorithm 3: Push</a></li><li class='sommaire-subsub'><a href='#sec_2_Stack__Algorithm_4_Pop'>Algorithm 4: Pop</a></li><li class='sommaire-subsub2'><a href='#sec_2_Stack__Underflow_and_overflow'>Underflow and overflow</a></li><li class='sommaire-item'><a href='#sec_3_Queue'>3) Queue</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Core_idea_FIFO'>Core idea (FIFO)</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Array_based_queue_representation_fixed_size'>Array-based queue representation (fixed size)</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Wrap_round_circular_queue'>Wrap-round (circular queue)</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Algorithm_1_Initialise_a_queue'>Algorithm 1: Initialise a queue</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Algorithm_2_Add_an_item_enQueue'>Algorithm 2: Add an item (enQueue)</a></li><li class='sommaire-subsub'><a href='#sec_3_Queue__Algorithm_3_Remove_an_item_deQueue'>Algorithm 3: Remove an item (deQueue)</a></li><li class='sommaire-item'><a href='#sec_4_Binary_Tree'>4) Binary Tree</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Core_idea_and_key_terms'>Core idea and key terms</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Array_representation_of_the_tree'>Array representation of the tree</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Initialising_an_empty_tree'>Initialising an empty tree</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Inserting_a_new_value'>Inserting a new value</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Finding_a_value_search'>Finding a value (search)</a></li><li class='sommaire-subsub'><a href='#sec_4_Binary_Tree__Why_this_tree_supports_faster_search_than_linear_scanning'>Why this tree supports faster search than linear scanning</a></li><li class='sommaire-item'><a href='#sec_5_Graph'>5) Graph</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__What_a_graph_is'>What a graph is</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__Key_features_of_a_graph'>Key features of a graph</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__Weighted_graphs'>Weighted graphs</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__Directed_and_undirected'>Directed and undirected</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__Paths_and_cycles'>Paths and cycles</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__Why_graphs_are_useful'>Why graphs are useful</a></li><li class='sommaire-subsub'><a href='#sec_5_Graph__How_a_graph_can_be_stored'>How a graph can be stored</a></li><li class='sommaire-subsub2'><a href='#sec_5_Graph__Adjacency_matrix'>Adjacency matrix</a></li><li class='sommaire-subsub2'><a href='#sec_5_Graph__Adjacency_list'>Adjacency list</a></li></ul></div></aside>

    <section class="content">
      <section class="syllabus-card">
        <div class="hero-title"><div class='hero-code'>19.1c:</div><div class='hero-rest'>Show understanding of and use Abstract Data Types (ADT):</div></div>
        <div class="targets-wrap"><ul class='targets level-0'>
<li>Write algorithms to find an item in each of the following: linked list, binary tree</li>
<li>Write algorithms to insert an item into each of the following: stack, queue, linked list, binary tree</li>
<li>Write algorithms to delete an item from each of the following: stack, queue, linked list</li>
<li>Show understanding that a graph is an example of an ADT. Describe the key features of a graph and justify its use for a given situation. (Candidates will not be required to write code for this structure.)</li>
</ul></div>
      </section>
      
<section class="note-card" id="sec_1_Linked_List">
  <h2 class="subheading">1) Linked List</h2>
  <div class="note-body"><a id='sec_1_Linked_List__What_a_linked_list_node_stores'></a><h3 class='subsub-heading level3'>What a linked list node stores</h3>



<ul class='note-list level-0'>
  <li>A linked list is made of nodes.</li>
  <li>Each node stores:</li>
  <ul class='note-list level-1'>
    <li>a Data field (the value)</li>
    <li>a Pointer (also called link) field that stores where the next node is</li>
  </ul>
  <li>The pointer of the last node stores a null value (meaning “no next node”).</li>
</ul>

<a id='sec_1_Linked_List__Array_based_linked_list'></a>
<h3 class='subsub-heading level3'>Array based linked list</h3>

<p class='note-paragraph'>
A common way to implement a linked list is to store nodes inside an array (or in Python, a list).
Each array position represents one node record.
</p>

<ul class='note-list level-0'>
  <li>Each array position is a node record with:</li>
  <ul class='note-list level-1'>
    <li>Data</li>
    <li>Pointer (the index of the next node, or NullPointer).</li>
  </ul>
  <li>StartPointer stores the index of the first node in the list (or NullPointer if the list is empty).</li>
  <li>FreeListPtr stores the index of the first free (unused) node.</li>
  <li>NullPointer is often -1 when array indices start at 0.</li>
</ul>

<p class='note-paragraph'>
In the Python code, the array-based linked list is created as a list of nodes where each node is stored as a pair:
<code>[Data, Pointer]</code>. During initialisation, every node starts as unused, so its Data is set to <code>-1</code>.
</p>

<p class='note-paragraph'>
Initialisation also sets:
</p>
<ul class='note-list level-0'>
  <li><code>FirstNode</code> to NullPointer to show the linked list is empty (StartPointer).</li>
  <li><code>FirstEmpty</code> to <code>0</code> so the first free node is at index 0 (FreeListPtr).</li>
</ul>

<a id='sec_1_Linked_List__The_free_list_how_unused_nodes_are_tracked'></a>
<h3 class='subsub-heading level3'>The free list (how unused nodes are tracked)</h3>

<ul class='note-list level-0'>
  <li>Unused nodes are connected together in their own linked list called the free list.</li>
  <li>FreeListPtr points to the first free node, and each free node’s pointer links to the next free node.</li>
  <li>When you insert a node, you take the first node from the free list and move FreeListPtr forward.</li>
  <li>When you delete a node, you return that node to the free list by linking it back to FreeListPtr.</li>
</ul>

<p class='note-paragraph'>
In <code>linkedInitialisePython(size)</code>, the free list is built by setting each node’s pointer to the next index:
index 0 points to 1, 1 points to 2, and so on, until the last node points to NullPointer.
This creates a chain of free nodes that can be used later for insertion.
</p>
<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#linkedInitialisePseudo" data-annex="linkedInitialisePseudo">linkedInitialisePseudo (annex)</a></li>
  <li><a class="annex-link" href="annex_19_1.html#linkedInitialisePython" data-annex="linkedInitialisePython">linkedInitialisePython (annex)</a></li>
</ul>





<a id='sec_1_Linked_List__Algorithm_1_Find_search_in_a_linked_list'></a><h3 class='subsub-heading level3'>Algorithm 1: Find (search) in a linked list</h3>




<p class='note-paragraph'>
Goal: locate the node whose Data equals a target value in an array-based linked list.
</p>

<p class='note-paragraph'>
In Python, the linked list is stored as a <strong>2D list</strong>. Each node is stored as:
</p>

<ul class='note-list level-0'>
  <li><code>LinkedList[index][0]</code> → the <strong>Data</strong> in the node</li>
  <li><code>LinkedList[index][1]</code> → the <strong>Pointer</strong> (index of the next node)</li>
</ul>

<p class='note-paragraph'>
The <strong>first index</strong> selects which node is accessed, and the <strong>second index</strong> selects Data (<code>0</code>) or Pointer (<code>1</code>).
</p>

<p class='note-paragraph'>
Moving to the next node is done by <strong>replacing the current pointer with the next pointer</strong>.
This happens using:
<code>current_ptr = LinkedList[current_ptr][1]</code>.  
When the pointer value is replaced, the algorithm automatically moves to the next node.
</p>

<ul class='note-list level-0'>
  <li>Start from <strong>StartPointer</strong>.</li>
  <li>Repeat:</li>
  <ul class='note-list level-1'>
    <li>compare the Data using <code>LinkedList[current_ptr][0]</code></li>
    <li>move to the next node by replacing the pointer using <code>current_ptr = LinkedList[current_ptr][1]</code></li>
  </ul>
  <li>Stop when:</li>
  <ul class='note-list level-1'>
    <li>the Data matches the target, or</li>
    <li>the pointer becomes <strong>NullPointer</strong>.</li>
  </ul>
</ul>





<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
<li><a class="annex-link" href="annex_19_1.html#linkedFindPseudo" data-annex="linkedFindPseudo">linkedFindPseudo (annex)</a> for the pseudocode</li>
<li><a class="annex-link" href="annex_19_1.html#linkedFindPython" data-annex="linkedFindPython">linkedFindPython (annex)</a> for the Python version</li>
</ul>
<a id='sec_1_Linked_List__Algorithm_2_Insertion_of_a_new_node'></a><h3 class='subsub-heading level3'>Algorithm 2: Insertion of a new node</h3>







<p class='note-paragraph'>
Insertion is done at the <strong>front</strong> of the list, so no traversal is required.
</p>

<ul class='note-list level-0'>
  <li>If <strong>FreeListPtr</strong> is <strong>NullPointer</strong>, there are no free nodes and insertion fails.</li>
  <li>The first free node is taken from the <strong>free list</strong> to store the new item.</li>
</ul>

<p class='note-paragraph'>
Before storing the new data, the pointer of the free node is saved.
This is necessary because the pointer currently stores the <strong>next free node</strong>.
If it is not saved, the rest of the free list would be lost.
</p>

<ul class='note-list level-0'>
  <li>The new data is stored in the free node.</li>
  <li>The node’s pointer is updated to point to the old first node.</li>
  <li>The <strong>StartPointer</strong> is replaced with the index of the new node.</li>
</ul>

<p class='note-paragraph'>
Key idea: insertion works by <strong>removing one node from the free list</strong> and
<strong>adding it to the front of the linked list</strong> by updating pointers.
</p>


<p class='note-paragraph'>
Variants students may meet in the exam:
</p>
<ul class='note-list level-0'>
  <li>insert at the end</li>
  <li>insert into an ordered position (insert between nodes after searching for the correct position)</li>
</ul>









<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
<li><a class="annex-link" href="annex_19_1.html#linkedInsertPseudo" data-annex="linkedInsertPseudo">linkedInsertPseudo (annex)</a></li>
<li><a class="annex-link" href="annex_19_1.html#linkedInsertPython" data-annex="linkedInsertPython">linkedInsertPython (annex)</a></li>
</ul>
<a id='sec_1_Linked_List__Algorithm_3_Delete_remove_one_item'></a><h3 class='subsub-heading level3'>Algorithm 3: Delete (remove one item)</h3>





<p class='note-paragraph'>
Goal: remove the first node whose Data matches the target.
</p>

<p class='note-paragraph'>
Key idea: to delete a node, we must also know the node <strong>before</strong> it, so we can re-link the list.
This is why the algorithm uses two pointers: <code>this_ptr</code> (current node) and <code>prev_ptr</code> (previous node).
</p>

<ul class='note-list level-0'>
  <li><strong>Search for the target:</strong> traverse from StartPointer until the Data matches or NullPointer is reached.</li>
  <li><strong>If NullPointer is reached:</strong> the item is not in the list, so deletion fails.</li>
  <li><strong>Two deletion cases:</strong></li>
  <ul class='note-list level-1'>
    <li><strong>Deleting the first node:</strong> update StartPointer to the second node (the current first node’s pointer).</li>
    <li><strong>Deleting any other node:</strong> update the previous node’s pointer to skip the deleted node (link previous directly to the node after it).</li>
  </ul>
  <li><strong>Return the deleted node to the free list:</strong> the deleted node is not destroyed; it is reused later.</li>
  <ul class='note-list level-1'>
    <li>make the deleted node’s pointer point to the current FreeListPtr</li>
    <li>move FreeListPtr to the deleted node</li>
    <li>clear the Data field (e.g. set to <code>-1</code>)</li>
  </ul>
</ul>

<p class='note-paragraph'>
Summary: deletion works by <strong>removing a node from the linked list</strong> (by pointer changes) and <strong>adding that node to the front of the free list</strong>.
</p>



<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
<li><a class="annex-link" href="annex_19_1.html#linkedDeletePseudo" data-annex="linkedDeletePseudo">linkedDeletePseudo (annex)</a></li>
<li><a class="annex-link" href="annex_19_1.html#linkedDeletePython" data-annex="linkedDeletePython">linkedDeletePython (annex)</a></li>
</ul></div>
</section>



<section class="note-card" id="sec_2_Stack">
  <h2 class="subheading">2) Stack</h2>
  <div class="note-body">

<p class='note-paragraph'><strong>What a stack is</strong></p>
<ul class='note-list level-0'>
  <li>A stack is a data structure that follows the Last-In, First-Out (LIFO) principle.</li>
  <li>The most recently added item is the first item removed.</li>
  <li>All operations take place at one end called the <strong>top</strong>.</li>
</ul>

<p class='note-paragraph'><strong>How the stack is stored</strong></p>
<ul class='note-list level-0'>
  <li>A stack can be stored in a fixed-size array.</li>
  <li>An integer pointer called <strong>TopPointer</strong> stores the index of the current top item.</li>
  <li>When an item is pushed, <strong>TopPointer increases</strong>.</li>
  <li>When an item is popped, <strong>TopPointer decreases</strong>.</li>
</ul>

<p class='note-paragraph'>
In this implementation, the stack uses <strong>1-based indexing</strong>:
</p>
<ul class='note-list level-0'>
  <li><strong>BasePointer</strong> is set to 1 (first valid stack position).</li>
  <li><strong>TopPointer</strong> is set to 0 when the stack is empty.</li>
</ul>

<p class='note-paragraph'>
Because index <code>0</code> is not used, the array is created with one extra element
(<code>MAX_STACK_SIZE + 1</code>) so that valid stack positions run from <code>1</code> to <code>MAX_STACK_SIZE</code>.
</p>

<div class='figure-wrap'>
  <img class='doc-figure size-70' src='images/stack.png' alt='Stack diagram'>
</div>

<a id='sec_2_Stack__Algorithm_0_Initialise_the_stack'></a>
<h3 class='subsub-heading level3'>Algorithm 0: Initialise the stack</h3>

<ul class='note-list level-0'>
  <li>Initialisation sets the stack to an empty state.</li>
  <li><strong>BasePointer</strong> is set to 1 and <strong>TopPointer</strong> is set to 0.</li>
  <li>The array positions from <code>1</code> to <code>MAX_STACK_SIZE</code> are cleared.</li>
</ul>

<p class='note-paragraph'>
The initialise loop starts from <code>1</code> (not <code>0</code>) because index <code>0</code> is not part of the stack.
</p>

<p class='note-paragraph'>
The stack is empty when <code>TopPointer &lt; BasePointer</code>.
</p>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#stackInitialisePseudo" data-annex="stackInitialisePseudo">stackInitialisePseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#stackInitialisePython" data-annex="stackInitialisePython">stackInitialisePython</a></li>
</ul>

<a id='sec_2_Stack__Algorithm_1_Check_if_the_stack_is_empty'></a>
<h3 class='subsub-heading level3'>Algorithm 1: Check if the stack is empty</h3>

<ul class='note-list level-0'>
  <li>A stack is empty when it contains no items.</li>
  <li>This is checked by verifying that <code>TopPointer &lt; BasePointer</code>.</li>
  <li>This prevents <strong>underflow</strong>.</li>
</ul>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#stackIsEmptyPseudo" data-annex="stackIsEmptyPseudo">stackIsEmptyPseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#stackIsEmptyPython" data-annex="stackIsEmptyPython">stackIsEmptyPython</a></li>
</ul>

<a id='sec_2_Stack__Algorithm_2_Check_if_the_stack_is_full'></a>
<h3 class='subsub-heading level3'>Algorithm 2: Check if the stack is full</h3>

<ul class='note-list level-0'>
  <li>A stack is full when no free space remains in the array.</li>
  <li>The stack is full when <code>TopPointer = MAX_STACK_SIZE</code>.</li>
  <li>This prevents <strong>overflow</strong>.</li>
</ul>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#stackIsFullPseudo" data-annex="stackIsFullPseudo">stackIsFullPseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#stackIsFullPython" data-annex="stackIsFullPython">stackIsFullPython</a></li>
</ul>

<a id='sec_2_Stack__Algorithm_3_Push'></a>
<h3 class='subsub-heading level3'>Algorithm 3: Push</h3>

<ul class='note-list level-0'>
  <li>Push adds a new item to the top of the stack.</li>
  <li>The stack must not be full before insertion.</li>
  <li><strong>TopPointer</strong> increases by one, then the item is stored at that position.</li>
</ul>

<p class='note-paragraph'>
Key idea: <strong>TopPointer always points to the current top item</strong>.  
So the pointer is moved first to the next free position, then the new item becomes the top.
</p>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#stackPushPseudo" data-annex="stackPushPseudo">stackPushPseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#stackPushPython" data-annex="stackPushPython">stackPushPython</a></li>
</ul>

<a id='sec_2_Stack__Algorithm_4_Pop'></a>
<h3 class='subsub-heading level3'>Algorithm 4: Pop</h3>

<ul class='note-list level-0'>
  <li>Pop removes and returns the item at the top of the stack.</li>
  <li>The stack must not be empty before removal.</li>
  <li>The item at <strong>TopPointer</strong> is read, then <strong>TopPointer</strong> decreases by one.</li>
</ul>

<p class='note-paragraph'>
In the Python code, the array position is cleared after popping (set to an empty value).  
This is good practice because it removes the old value, although the stack logic mainly depends on <strong>TopPointer</strong>.
</p>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#stackPopPseudo" data-annex="stackPopPseudo">stackPopPseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#stackPopPython" data-annex="stackPopPython">stackPopPython</a></li>
</ul>

<a id='sec_2_Stack__Underflow_and_overflow'></a>
<h4 class='subsub-heading level4'>Underflow and overflow</h4>

<ul class='note-list level-0'>
  <li><strong>Underflow</strong>: attempting to pop when the stack is empty.</li>
  <li><strong>Overflow</strong>: attempting to push when the stack is full.</li>
</ul>

</div>
</section>




<section class="note-card" id="sec_3_Queue">
  <h2 class="subheading">3) Queue</h2>
  <div class="note-body">

<a id='sec_3_Queue__Core_idea_FIFO'></a>
<h3 class='subsub-heading level3'>Core idea (FIFO)</h3>

<ul class='note-list level-0'>
  <li>A queue is a First-In, First-Out (FIFO) structure: the first item added is the first item removed.</li>
  <li>The <strong>front</strong> is where items are removed (deQueue).</li>
  <li>The <strong>rear</strong> is where items are added (enQueue).</li>
</ul>

<a id='sec_3_Queue__Array_based_queue_representation_fixed_size'></a>
<h3 class='subsub-heading level3'>Array-based queue representation (fixed size)</h3>

<p class='note-paragraph'>
A queue can be stored in a fixed-size array and controlled using pointers and a counter:
</p>

<ul class='note-list level-0'>
  <li><strong>HeadPointer</strong> points to the front item (the next item to remove).</li>
  <li><strong>TailPointer</strong> points to the rear item (the most recently added item).</li>
  <li><strong>NumberItems</strong> stores how many items are currently in the queue.</li>
</ul>

<p class='note-paragraph'>
In this implementation, the queue is empty when <code>NumberItems = 0</code>.
When the queue is empty, both pointers are also set to <code>-1</code>.
</p>

<div class='figure-wrap'>
  <img class='doc-figure size-70' src='images/queue.png' alt='queue diagram'>
</div>

<a id='sec_3_Queue__Wrap_round_circular_queue'></a>
<h3 class='subsub-heading level3'>Wrap-round (circular queue)</h3>

<p class='note-paragraph'>
In a fixed-size array, pointers must wrap back to the start when they reach the end of the array.
</p>

<ul class='note-list level-0'>
  <li>If increasing a pointer makes it reach <code>MAX_QUEUE_SIZE</code>, it is reset to <code>0</code>.</li>
  <li>This allows the queue to reuse spaces freed at the start of the array after removals.</li>
  <li>Wrap-round changes pointer values only; data is not moved.</li>
</ul>

<a id='sec_3_Queue__Algorithm_1_Initialise_a_queue'></a>
<h3 class='subsub-heading level3'>Algorithm 1: Initialise a queue</h3>

<ul class='note-list level-0'>
  <li>Initialisation sets the queue to an empty state.</li>
  <li><strong>HeadPointer</strong> and <strong>TailPointer</strong> are set to <code>-1</code>.</li>
  <li><strong>NumberItems</strong> is set to <code>0</code>.</li>
</ul>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#queueInitialisePseudo" data-annex="queueInitialisePseudo">queueInitialisePseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#queueInitialisePython" data-annex="queueInitialisePython">queueInitialisePython</a></li>
</ul>

<a id='sec_3_Queue__Algorithm_2_Add_an_item_enQueue'></a>
<h3 class='subsub-heading level3'>Algorithm 2: Add an item (enQueue)</h3>

<ul class='note-list level-0'>
  <li>Purpose: add a new item at the rear of the queue.</li>
  <li>If <code>NumberItems = MAX_QUEUE_SIZE</code>, the queue is full and enQueue fails.</li>
</ul>

<p class='note-paragraph'>
Special case: if the queue is empty (<code>TailPointer = -1</code>), both pointers are set to <code>0</code> and the first item is stored.
This establishes the initial front and rear positions.
</p>

<p class='note-paragraph'>
Otherwise, <strong>TailPointer is moved forward</strong>. If it is at the last index, it wraps back to <code>0</code>.
The new item is stored at the updated TailPointer position.
</p>

<p class='note-paragraph'>
Finally, <code>NumberItems</code> is increased by 1.
</p>

<p class='note-paragraph'>
Key idea: enQueue adds an item by moving the rear pointer, not by shifting data.
</p>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#queueEnqueuePseudo" data-annex="queueEnqueuePseudo">queueEnqueuePseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#queueEnqueuePython" data-annex="queueEnqueuePython">queueEnqueuePython</a></li>
</ul>

<a id='sec_3_Queue__Algorithm_3_Remove_an_item_deQueue'></a>
<h3 class='subsub-heading level3'>Algorithm 3: Remove an item (deQueue)</h3>

<ul class='note-list level-0'>
  <li>Purpose: remove and return the item at the front of the queue.</li>
  <li>If <code>NumberItems = 0</code>, the queue is empty and deQueue fails (returns <code>-1</code> in this implementation).</li>
</ul>

<p class='note-paragraph'>
The item at <strong>HeadPointer</strong> is read, then <strong>HeadPointer is moved forward</strong>.
If it reaches <code>MAX_QUEUE_SIZE</code>, it wraps back to <code>0</code>.
</p>

<p class='note-paragraph'>
After removal, <code>NumberItems</code> is decreased by 1.
If <code>NumberItems</code> becomes 0, both pointers are reset to <code>-1</code> to represent an empty queue.
</p>

<p class='note-paragraph'>
Key idea: deQueue removes an item by moving the front pointer, not by shifting elements.
</p>

<p class='note-paragraph'>See Annex:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#queueDequeuePseudo" data-annex="queueDequeuePseudo">queueDequeuePseudo</a></li>
  <li><a class="annex-link" href="annex_19_1.html#queueDequeuePython" data-annex="queueDequeuePython">queueDequeuePython</a></li>
</ul>

</div>
</section>







<section class="note-card" id="sec_4_Binary_Tree">
  <h2 class="subheading">4) Binary Tree</h2>
  <div class="note-body">

<a id='sec_4_Binary_Tree__Core_idea_and_key_terms'></a>
<h3 class='subsub-heading level3'>Core idea and key terms</h3>

<ul class='note-list level-0'>
  <li>A binary tree is a structure in which each node can have at most two children.</li>
  <li>An ordered binary tree (binary search tree) stores values so that:</li>
  <ul class='note-list level-1'>
    <li>if the new value is smaller than the current node’s value, follow the left pointer</li>
    <li>if the new value is greater than or equal to the current node’s value, follow the right pointer</li>
  </ul>
  <li>Root: the first node in the tree; RootPointer stores the index of the root node.</li>
  <li>A null pointer indicates “no child” below a node on that side.</li>
  <li>The following image shows a conceptual diagram of an ordered binary tree:</li>
</ul>

<div class='figure-wrap'><img class='doc-figure size-70' src='images/img_02.png' alt=''></div>

<p class='note-paragraph'>
For example, if we want to add a new node with data value D to the binary tree in Figure 23.03:
1 Start at the root node.
2 D is smaller than F, so turn left.
3 D is greater than C, so turn right.
4 D is smaller than E, so turn left.
5 There is no branch going left from E, so we add D as a left child from E.
</p>

<a id='sec_4_Binary_Tree__Array_representation_of_the_tree'></a>
<h3 class='subsub-heading level3'>Array representation of the tree</h3>

<ul class='note-list level-0'>
  <li>The tree can be stored in an array of records, where each record represents one node and contains:</li>
  <ul class='note-list level-1'>
    <li>Data</li>
    <li>LeftPointer</li>
    <li>RightPointer</li>
  </ul>
  <li>A constant NullPointer = -1 is used when array indices start at 0.</li>
  <li>Unused nodes are tracked so that insertion can take the next available space.</li>
</ul>

<p class='note-paragraph'>
In the Python code, the tree is stored as a 2D list where each node is stored in the fixed order:
<code>[LeftPointer, Data, RightPointer]</code>.
This means:
<code>ArrayNodes[i][0]</code> is the left child index,
<code>ArrayNodes[i][1]</code> is the data value,
and <code>ArrayNodes[i][2]</code> is the right child index.
</p>

<a id='sec_4_Binary_Tree__Initialising_an_empty_tree'></a>
<h3 class='subsub-heading level3'>Initialising an empty tree</h3>

<ul class='note-list level-0'>
  <li>Initialisation sets:</li>
  <ul class='note-list level-1'>
    <li>RootPointer to NullPointer (empty tree)</li>
    <li>the “free space” pointer so that insertions know where unused nodes are</li>
  </ul>
</ul>

<p class='note-paragraph'>
In the Python code, unused nodes are tracked using <strong>FreeNode</strong>, which stores the index of the next unused array position.
Each new insertion uses the node at <code>FreeNode</code>, then <code>FreeNode</code> is increased by 1.
</p>

<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeInitialisePseudo" data-annex="binaryTreeInitialisePseudo">binaryTreeInitialisePseudo (annex)</a></li>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeInitialisePython" data-annex="binaryTreeInitialisePython">binaryTreeInitialisePython (annex)</a></li>
</ul>

<a id='sec_4_Binary_Tree__Inserting_a_new_value'></a>
<h3 class='subsub-heading level3'>Inserting a new value</h3>

<ul class='note-list level-0'>
  <li>Insertion first checks there is space available in the array.</li>
  <li>A new node is created in a free position, its Data is stored, and both child pointers are set to NullPointer (it starts as a leaf).</li>
  <li>If the tree is empty, the new node becomes the root.</li>
  <li>Otherwise, start at the root and repeatedly compare:</li>
  <ul class='note-list level-1'>
    <li>if current node value &gt; new value, go left</li>
    <li>otherwise go right</li>
  </ul>
  <li>Stop when there is no pointer to follow, then attach the new node at that leaf position.</li>
  <li>Example reasoning (conceptual): to insert D, compare at each node and turn left or right until there is no branch, then insert at that position.</li>
</ul>

<p class='note-paragraph'>
In the Python code, the new node is prepared at <code>FreeNode</code> by storing the data and setting both child pointers to <code>-1</code>.
To attach it, the algorithm travels down from the root and changes exactly <strong>one</strong> pointer in the parent node
(either its LeftPointer or RightPointer) so it points to <code>FreeNode</code>.
</p>

<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeInsertPseudo" data-annex="binaryTreeInsertPseudo">binaryTreeInsertPseudo (annex)</a></li>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeInsertPython" data-annex="binaryTreeInsertPython">binaryTreeInsertPython (annex)</a></li>
</ul>

<a id='sec_4_Binary_Tree__Finding_a_value_search'></a>
<h3 class='subsub-heading level3'>Finding a value (search)</h3>

<ul class='note-list level-0'>
  <li>Searching starts from the root and follows pointers while:</li>
  <ul class='note-list level-1'>
    <li>the current pointer is not NullPointer</li>
    <li>and the data does not match the search item</li>
  </ul>
  <li>At each step:</li>
  <ul class='note-list level-1'>
    <li>if current node value &gt; search item, go left</li>
    <li>otherwise go right</li>
  </ul>
  <li>If the search fails, the algorithm returns NullPointer.</li>
</ul>

<p class='note-paragraph'>
In the Python code, searching works by updating <code>CurrentNode</code>.
At each node, the search compares <code>SearchItem</code> with the node’s Data (<code>ArrayNodes[CurrentNode][1]</code>).
If the item is smaller it replaces <code>CurrentNode</code> with the left pointer; otherwise it replaces it with the right pointer.
This moves automatically to the next node in the tree.
</p>

<p class='note-paragraph'>See:</p>
<ul class='note-list level-0'>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeFindPseudo" data-annex="binaryTreeFindPseudo">binaryTreeFindPseudo (annex)</a></li>
  <li><a class="annex-link" href="annex_19_1.html#binaryTreeFindPython" data-annex="binaryTreeFindPython">binaryTreeFindPython (annex)</a></li>
</ul>

<a id='sec_4_Binary_Tree__Why_this_tree_supports_faster_search_than_linear_scanning'></a>
<h3 class='subsub-heading level3'>Why this tree supports faster search than linear scanning</h3>

<ul class='note-list level-0'>
  <li>Because it is ordered and branches left or right based on comparisons, it provides faster search than linear search and linked-list search.</li>
  <li>When inserting, existing nodes are not moved; only one pointer is updated to link the new node into the tree.</li>
</ul>

</div>
</section>









<section class="note-card" id="sec_5_Graph">
  <h2 class="subheading">5) Graph</h2>
  <div class="note-body"><a id='sec_5_Graph__What_a_graph_is'></a><h3 class='subsub-heading level3'>What a graph is</h3>
<ul class='note-list level-0'>
<li>A graph is an abstract data type made of vertices (nodes) and edges.</li>
<li>Graphs are used to represent relationships between items.</li>
<li>A graph is a non-linear data structure.</li>
</ul>
<a id='sec_5_Graph__Key_features_of_a_graph'></a><h3 class='subsub-heading level3'>Key features of a graph</h3>
<ul class='note-list level-0'>
<li>Vertices (nodes) represent the items being connected (for example, stations in a transport network).</li>
<li>Edges represent the connections between vertices (for example, train lines between stations).</li>
<li>Two vertices connected by an edge are neighbours.</li>
</ul>
<p class='note-paragraph'>The following image is a graph showing part of the London Underground map:</p>
<div class='figure-wrap'><img class='doc-figure' src='images/img_03.png' alt=''></div>
<p class='note-paragraph'>The vertices labelled A to F are the underground stations and the edges represent train
lines connecting the stations</p>
<a id='sec_5_Graph__Weighted_graphs'></a><h3 class='subsub-heading level3'>Weighted graphs</h3>
<ul class='note-list level-0'>
<li>In a weighted (labelled) graph, an edge stores a value that represents something meaningful (for example, travel time).</li>
<li>Weights can represent measures such as distance or cost in a network.</li>
</ul>
<p class='note-paragraph'>The following Weighted graph shows the travelling times between stations</p>
<div class='figure-wrap'><img class='doc-figure' src='images/img_03.png' alt=''></div>
<a id='sec_5_Graph__Directed_and_undirected'></a><h3 class='subsub-heading level3'>Directed and undirected</h3>
<ul class='note-list level-0'>
<li>Graphs can be undirected or directed.</li>
<li>A directed graph is used when the connection has a direction (for example, a one-way system).</li>
<li>Direction may matter because the relationship or cost may differ depending on the direction.</li>
</ul>
<p class='note-paragraph'>The following is a directed graph:</p>
<div class='figure-wrap'><img class='doc-figure' src='images/img_03.png' alt=''></div>
<a id='sec_5_Graph__Paths_and_cycles'></a><h3 class='subsub-heading level3'>Paths and cycles</h3>
<ul class='note-list level-0'>
<li>A path is a sequence of connected nodes between two nodes.</li>
<li>A cycle is a path that returns to the starting node.</li>
</ul>
<a id='sec_5_Graph__Why_graphs_are_useful'></a><h3 class='subsub-heading level3'>Why graphs are useful</h3>
<p class='note-paragraph'>Graphs are appropriate when a problem is naturally a network of connected items:</p>
<ul class='note-list level-0'>
<li>Transport networks: nodes are stations; edges are direct connections; weights can store time, distance, or cost.</li>
<li>Websites: each page is a node; edges represent links between pages.</li>
<li>Social networks: each person is a node; edges connect friends.</li>
<li>Route choice: routes can be compared by using the weights along each route (for example, comparing travel-time routes).</li>
</ul>
<a id='sec_5_Graph__How_a_graph_can_be_stored'></a><h3 class='subsub-heading level3'>How a graph can be stored</h3>
<p class='note-paragraph'>Even though you are not required to write code, it is important to understand common representations.</p>
<a id='sec_5_Graph__Adjacency_matrix'></a><h4 class='subsub-heading level4'>Adjacency matrix</h4>
<ul class='note-list level-0'>
<li>An adjacency matrix stores the relationship between every vertex and all other vertices.</li>
<li>For an unweighted graph:</li>
<ul class='note-list level-1'>
<li>1 means an edge exists, 0 means no edge.</li>
</ul>
<li>For a weighted graph:</li>
<ul class='note-list level-1'>
<li>the weight replaces the 1,</li>
<li>and ∞ can be used when there is no edge.</li>
</ul>
</ul>
<p class='note-paragraph'>The following shows the adjacency matrix for the previous unweighted and weighted graphs:</p>
<div class='figure-wrap'><img class='doc-figure' src='images/img_06.png' alt=''></div>
<a id='sec_5_Graph__Adjacency_list'></a><h4 class='subsub-heading level4'>Adjacency list</h4>
<ul class='note-list level-0'>
<li>An adjacency list stores, for each vertex, only the vertices it is connected to (so entries exist only when there is an edge).</li>
<li>For a weighted graph, each connection also stores its weight. This is shown in the following:</li>
</ul>
<div class='figure-wrap'><img class='doc-figure' src='images/img_07.png' alt=''></div></div>
</section>

    </section>
  </main>

  <div class="modal-backdrop" id="annexModalBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Annex code">
    <div class="modal-header">
      <div class="modal-title" id="annexModalTitle"></div>
      <div class="modal-subtitle" id="annexModalSubtitle"></div>
      <button class="modal-close" id="annexModalClose" type="button">Close</button>
    </div>
    <div class="modal-body">
      <div class="modal-codewrap" id="annexModalCodeWrap"></div>
      <div class="tip-panel visible" id="modalTipPanel" aria-hidden="false"></div>
    </div>
  </div>
</div>
  <script src="script.js"></script>
</body>
</html>
