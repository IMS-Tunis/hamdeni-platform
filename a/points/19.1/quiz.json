{
  "questions": [
    {
      "type": "mcq",
      "question": "A list of unsorted values is searched by checking each element from index 0 to the end until the target value is found or the list ends. Which searching algorithm is being used?",
      "options": [
        "Binary search",
        "Linear search",
        "Insertion sort",
        "Hash-based search"
      ],
      "answer": "Linear search"
    },
    {
      "type": "mcq",
      "question": "Which condition must be satisfied before binary search can be used?",
      "options": [
        "The data is random",
        "All values are identical",
        "The data is sorted",
        "The data is stored in a linked list"
      ],
      "answer": "The data is sorted"
    },
    {
      "type": "mcq",
      "question": "Which sorting algorithm repeatedly compares and swaps neighbouring items?",
      "options": [
        "Selection sort",
        "Insertion sort",
        "Bubble sort",
        "Merge sort"
      ],
      "answer": "Bubble sort"
    },
    {
      "type": "mcq",
      "question": "Which sorting algorithm usually performs best on an almost sorted list (among simple comparison sorts such as bubble and insertion)?",
      "options": [
        "Bubble sort",
        "Insertion sort",
        "Binary search",
        "Linear search"
      ],
      "answer": "Insertion sort"
    },
    {
      "type": "mcq",
      "question": "Two sorting algorithms are applied to the same list. One repeatedly swaps adjacent elements. The other inserts each new element into its correct position in an already sorted section of the list. Which pairing correctly matches the algorithm to its behaviour?",
      "options": [
        "Bubble sort → adjacent swaps, Insertion sort → sorted section",
        "Insertion sort → adjacent swaps, Bubble sort → sorted section",
        "Binary search → adjacent swaps, Bubble sort → sorted section",
        "Selection sort → adjacent swaps, Insertion sort → sorted section"
      ],
      "answer": "Bubble sort → adjacent swaps, Insertion sort → sorted section"
    },
    {
      "type": "mcq",
      "question": "Which principle describes how a stack removes items?",
      "options": [
        "FIFO",
        "FILO",
        "LIFO",
        "Random"
      ],
      "answer": "LIFO"
    },
    {
      "type": "mcq",
      "question": "Which abstract data type removes items in the same order they were added?",
      "options": [
        "Stack",
        "Tree",
        "Queue",
        "Graph"
      ],
      "answer": "Queue"
    },
    {
      "type": "mcq",
      "question": "Which data structure represents relationships using nodes connected by edges?",
      "options": [
        "Tree",
        "Stack",
        "Graph",
        "Queue"
      ],
      "answer": "Graph"
    },
    {
      "type": "match",
      "question": "Match each abstract data type with its organisational principle.",
      "pairs": {
        "Stack": "LIFO",
        "Queue": "FIFO",
        "Tree": "Hierarchical",
        "Graph": "Network"
      }
    },
    {
      "type": "mcq",
      "question": "Which data structures are commonly used to implement a stack?",
      "options": [
        "Graphs only",
        "Arrays or linked lists",
        "Trees only",
        "Hash tables only"
      ],
      "answer": "Arrays or linked lists"
    },
    {
      "type": "mcq",
      "question": "Which implementation of a queue allows unused spaces to be reused efficiently?",
      "options": [
        "Linear array",
        "Circular array",
        "Binary tree",
        "Graph"
      ],
      "answer": "Circular array"
    },
    {
      "type": "mcq",
      "question": "How is a linked list most commonly implemented at a low level?",
      "options": [
        "Using objects only",
        "Using arrays with pointers",
        "Using hash tables",
        "Using stacks"
      ],
      "answer": "Using arrays with pointers"
    },
    {
      "type": "mcq",
      "question": "Which data structure can be used to implement a dictionary abstract data type?",
      "options": [
        "Stack",
        "Queue",
        "Hash table",
        "Binary tree only"
      ],
      "answer": "Hash table"
    },
    {
      "type": "mcq",
      "question": "Which factor has a direct impact on the memory usage and performance of an abstract data type?",
      "options": [
        "Variable names",
        "Choice of implementation",
        "Output format",
        "Data values only"
      ],
      "answer": "Choice of implementation"
    },
    {
      "type": "match",
      "question": "Match each abstract data type with one valid implementation method.",
      "pairs": {
        "Stack": "Array or linked list",
        "Queue": "Circular array",
        "Dictionary": "Hash table",
        "Binary tree": "Linked nodes"
      }
    },
    {
      "type": "true_false",
      "question": "The same abstract data type can be implemented in different ways.",
      "answer": "True"
    },
    {
      "type": "true_false",
      "question": "The choice of implementation can affect how fast an abstract data type operates.",
      "answer": "True"
    },
    {
      "type": "true_false",
      "question": "An abstract data type defines how data is stored in memory.",
      "answer": "False"
    },
    {
      "type": "mcq",
      "question": "Which Big O notation represents linear growth as input size increases?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": "O(n)"
    },
    {
      "type": "match",
      "question": "Match each Big O notation with its meaning.",
      "pairs": {
        "O(1)": "Constant",
        "O(log n)": "Logarithmic",
        "O(n)": "Linear",
        "O(n²)": "Quadratic"
      }
    },
    {
      "type": "true_false",
      "question": "An algorithm with O(log n) time complexity grows more slowly than one with O(n) time complexity.",
      "answer": "True"
    }
  ]
}