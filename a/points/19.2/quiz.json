{
  "questions": [
    {
      "type": "mcq",
      "question": "Which line represents the factorial base case in the given pseudocode pattern?",
      "options": [
        "RETURN n * Factorial(n − 1)",
        "IF n = 0 THEN RETURN 1",
        "IF n = 1 THEN RETURN 0",
        "RETURN Factorial(n)"
      ],
      "answer": "IF n = 0 THEN RETURN 1"
    },
    {
      "type": "mcq",
      "question": "Which set of base cases is stated for Fibonacci?",
      "options": [
        "F0 = 1 and F1 = 1",
        "F1 = 0 and F2 = 1",
        "F0 = 0 and F1 = 1",
        "F0 = 1 and F2 = 2"
      ],
      "answer": "F0 = 0 and F1 = 1"
    },
    {
      "type": "mcq",
      "question": "What is the general case formula for Fibonacci for n >= 2?",
      "options": [
        "Fn = F(n−1) × F(n−2)",
        "Fn = F(n−1) − F(n−2)",
        "Fn = F(n−1) + F(n−2)",
        "Fn = 2 × F(n−1)"
      ],
      "answer": "Fn = F(n−1) + F(n−2)"
    },
    {
      "type": "mcq",
      "question": "Which cost is explicitly associated with recursive calls?",
      "options": [
        "Disk space only",
        "Time and memory because every call must be stored until it returns",
        "Only compilation time",
        "Network overhead"
      ],
      "answer": "Time and memory because every call must be stored until it returns"
    },
    {
      "type": "true_false",
      "question": "A call such as Factorial(100) requires 100 recursive calls before returning.",
      "answer": "True"
    },
    {
      "type": "match",
      "question": "Match the recursion terms to their descriptions.",
      "pairs": {
        "Base case": "Terminating rule that returns an answer without making a further call",
        "General case": "Rule that solves the problem by calling the same routine on a smaller input",
        "State change": "Required progress on each call that moves toward the base case",
        "Unwinding": "Step-by-step return of results after the base case is reached"
      }
    },
    {
      "type": "match",
      "question": "Match the stack concepts to their behaviors.",
      "pairs": {
        "Push": "Added to the stack when a call is made during winding",
        "Pop": "Removed from the stack when a call finishes during unwinding",
        "Return address": "Ensures control returns to the correct place",
        "Local variables": "Values that belong only to the current call"
      }
    },
    {
      "type": "mcq",
      "question": "What does the stack guarantee during recursion?",
      "options": [
        "That the routine is faster than any loop",
        "That control returns to the correct place with the correct local values restored",
        "That no base case is required",
        "That only one call can exist at a time"
      ],
      "answer": "That control returns to the correct place with the correct local values restored"
    },
    {
      "type": "mcq",
      "question": "Which sequence reflects the call order shown for Factorial(3)?",
      "options": [
        "3 -> 2 -> 1 -> 0",
        "0 -> 1 -> 2 -> 3",
        "3 -> 3 -> 3 -> 3",
        "1 -> 2 -> 3 -> 4"
      ],
      "answer": "3 -> 2 -> 1 -> 0"
    },
    {
      "type": "mcq",
      "question": "When Factorial(0) returns 1 during the Factorial(3) run, what happens next?",
      "options": [
        "All frames are immediately cleared from the stack",
        "Each waiting call pops its frame, computes its result, and returns to its caller",
        "The program restarts from Factorial(3)",
        "The stack creates additional frames for error checking"
      ],
      "answer": "Each waiting call pops its frame, computes its result, and returns to its caller"
    }
  ]
}