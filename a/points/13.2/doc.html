<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IGCSE Computer Science - 13.2 File organisation and access</title>
  <link rel="stylesheet" href="../igcse-style.css">
<script defer src="/assets/js/paste-guard.js"></script>
</head>
<body>
<div class="container">
<div class="header-container">
<img src="../syllabus.png" alt="Syllabus Update" class="top-right-icon">
  <div class="title-row">
    <h1 class="section-title">13.2 File organisation and access</h1>
  </div>
  <div class="title-underline"></div>
  <p class="section-subtitle">Computer Science IGCSE notes, prepared by Dr. Hamdeni</p>
</div>
  <div class="section">
    <h2>13.2a. File organization methods</h2>
    <ul>
      <li><span class="official-note"> Computers store information as data in files, stored as records, and efficient retrieval requires that these files are organised using different methods. These files can be organised in serial, sequential or random method:</span>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="A method of file organisation in which records of data are physically stored in a file, one after another, in the order they were added to the file.">Serial file organisation:</span></span>
          <ul>
            <li><span class="official-note">Records are stored one after another in the order they are added, typically in chronological order.</span></li>
            <li><span class="official-note">New records are appended to the end of the file.</span></li>
            <li><span class="official-note">Access is sequential from the physical start of the file to the end.</span></li>
          </ul>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="A method of file organisation in which records of data are physically stored in a file, one after another, in a given order.">Sequential file organisation:</span></span>
          <ul>
            <li><span class="official-note">Records are stored in a defined order by a key field or by an index derived from a key.</span></li>
            <li><span class="official-note">New records are inserted in the correct position to preserve the key order.</span></li>
            <li><span class="official-note">Read and write operations proceed in the order of the key or index.</span></li>
            <li><span class="official-note">Searching can terminate early when the current record‚Äôs key exceeds the target key.<br></span></li>
          </ul>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="A method of file access in which a record can be physically found in a file without physically reading other records.">Random (Direct) File Organization:</span>.</span>
          <ul>
            <li><span class="official-note">The computer chooses a position for each record using a short calculation on the record‚Äôs key, so the record can be reached quickly later.<br></span></li>
          </ul>
      </li>
      <li><span class="official-note">Choosing File Organization and Access Methods:</span>
          <ul>
            <li><span class="official-note">Serial files: suitable for sequential processing such as transaction logs or batch runs.</span></li>
            <li><span class="official-note">Sequential files: appropriate when processing in key order is required, for example billing systems or sorted reports.</span></li>
            <li><span class="official-note">Random (or Direct) access files: preferred when fast access to individual records is needed, for example customer databases with frequent updates.<br><br><br></span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><span class="fun-tip">Analogy: Serial is like a logbook you keep writing at the end, sequential is like a register sorted by ID so you slip each new entry into its place, and random or direct is like numbered lockers chosen by a code from the key so you can go straight to the right door.<br></span></li>
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('13.2a. File organization methods')">
          üîë View Keywords on This Topic üîë
        </button>
        <button class="exam-button" onclick="openPopupQ('13.2a. File organization methods')">
          üëÅÔ∏è Quick Look at Exam Questions on This Topic üëÅÔ∏è
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>13.2b.  File access methods</h2>
    <ul>
      <li><span class="official-note"> There are different methods of <span class="keyword" data-tooltip="The method used to physically find a record in the file.">file access</span>. We will consider two of them: sequential access and direct access.</span>
      </li>
      <li><span class="official-note"><span class="keyword" data-tooltip="A method of file access in which records are searched one after another from the physical start of the file until the required record is found.">Sequential access</span></span>
          <ul>
            <li><span class="official-note">Records are read one by one from the physical start until the target is found or end of file is reached.</span></li>
            <li><span class="official-note">Used with serial and sequential files.</span></li>
            <li><span class="official-note">In serial files, the search checks each chronologically stored record; in sequential files, keys are compared and the search may stop early once the current key exceeds the target.<br></span></li>
          </ul>
      </li>
      <li><span class="official-note">Direct Access</span>
          <ul>
            <li><span class="official-note">Direct access jumps straight to a record‚Äôs position without reading earlier records.</span></li>
            <li><span class="official-note">A sequential file can support direct jumps if it keeps a small lookup list called an index that tells where each key‚Äôs record is stored.</span></li>
            <li><span class="official-note">Appropriate when rapid updates or retrievals of individual records are required, for example updating a customer‚Äôs details.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><span class="fun-tip">Analogy: Sequential access is like reading a book from page 1 until you reach the needed page, while direct access is like using the index to jump straight to the exact page.<br><br><br></span></li>
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('13.2b.  File access methods')">
          üîë View Keywords on This Topic üîë
        </button>
        <button class="exam-button" onclick="openPopupQ('13.2b.  File access methods')">
          üëÅÔ∏è Quick Look at Exam Questions on This Topic üëÅÔ∏è
        </button>
      </div>
    </ul>
  </div>
  <div class="section">
    <h2>13.2c. Hashing algorithms</h2>
    <ul>
      <li><span class="official-note"><span class="keyword" data-tooltip="A mathematical formula used to perform a calculation on the key field of the record; the result of the calculation gives the address where the record should be found.">Hashing algorithm</span> is a short calculation on the record‚Äôs key is used to choose a position in the file. This helps the program store the record and find it quickly later.</span>
      </li>
      <li><span class="official-note">If two different keys point to the same position, this is a <span class="keyword" data-tooltip="When the same address is calculated for different field values.">Collision</span>, so we need a simple rule to store and find both records:</span>
          <ul>
            <li><span class="official-note">1. Linear probing (called also <span class="keyword" data-tooltip="Store the record in the next free space when a collision occurs.">Open hash</span>): if the chosen position is taken, check the next position, and repeat until a free one is found.</span></li>
            <li><span class="official-note">2. Chaining (called also <span class="keyword" data-tooltip="Keep a number of overflow addresses at the end of the file and store the record in the next free space in the overflow area.">Closed hash</span>: keep a small list at the chosen position that holds all records that mapped there.</span></li>
          </ul>
      </li>
    </ul>
    <ul class="no-bullets">
      <li><div class="example-box">suppose positions are numbered 0 to 9.<br>	  A simple method is to divide the key by 10 and use the remainder as the position. <br> -Key 42 gives remainder 2, so it goes to position 2;<br> - key 15 gives remainder 5, so it goes to position 5. ==> If key 25 also gives remainder 5, either place it in the next free position (linear probing) or add it to the list at position 5 (chaining).</div></li>
      <li><div class="example-box"> Simple Hashing Algorithm Using a Numeric Key Field<br>  chosen a number D, with the remainder determining the storage address in the file. For example, with D=1000:<br> 	‚Ä¢ 0045 mod 1000 gives a remainder of 45 (address 45)<br> 	‚Ä¢ 2005 mod 1000 gives a remainder of 5 (address 5)<br> ‚Ä¢ 3005 mod 1000 also gives a remainder of 5 (address 5) ==>Collision<br> Using a prime number for D is advantageous because it reduces the likelihood of collisions, especially when certain key values are more common, thereby preventing multiple records from hashing to the same address.</div></li>
      <li><span class="fun-tip">Analogy: Assign students to rooms using student_number mod 10. If two map to room 3, you either try the next room until an empty one appears (linear probing) or keep a list of all students for room 3 on its door (chaining).</span></li>
      <div class="button-group">
        <button class="keyword-button" onclick="openPopupK('13.2c. Hashing algorithms')">
          üîë View Keywords on This Topic üîë
        </button>
        <button class="exam-button" onclick="openPopupQ('13.2c. Hashing algorithms')">
          üëÅÔ∏è Quick Look at Exam Questions on This Topic üëÅÔ∏è
        </button>
      </div>
    </ul>
  </div>
</div>
<script src="popup-script.js"></script>
 <script>
      window.addEventListener('load', function () {
        const height = document.body.scrollHeight;
        window.parent.postMessage({ type: 'resize', height }, '*');
      });
    </script>
</body>
</html>