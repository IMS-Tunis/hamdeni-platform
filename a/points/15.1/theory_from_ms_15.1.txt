15.1 Processors, Parallel Processing and Virtual Machines – Theory Notes from Mark Schemes

15.1a RISC and CISC processors

1. Reduced Instruction Set Computer (RISC) processors are characterised by simple, fixed-length instructions that typically execute in a single clock cycle, extensive use of CPU registers, a relatively small instruction set with few addressing modes, frequent use of pipelining and load/store architectures, hardwired or dedicated control units, significant use of caching, possible use of branch prediction, and extensive use of main memory (RAM).
2. Key features of RISC processors include simple instructions, fixed-length instruction formats, execution of most instructions in a single clock cycle, extensive use of registers for fast data access, and the use of pipelining to allow overlapping execution of instructions.
3. In contrast to CISC processors, which have large and complex instruction sets with many formats and addressing modes, relatively few registers, complex circuits and programmable control units, frequent reliance on cache, and instructions that may require many clock cycles, RISC processors use simple, fixed-length instructions that execute in one clock cycle, employ many registers, make systematic use of pipelining, and use hardwired control units.
4. The main differences between RISC and CISC processors are that RISC processors have fewer and simpler instructions, more registers, fewer instruction formats and addressing modes, simpler circuits, fixed-length instructions that usually execute in a single cycle, better pipeline behaviour, greater use of main memory, hardwired control units, and load/store-only memory access, whereas CISC processors have more and more complex instructions, fewer registers, many instruction formats and addressing modes, more complex circuits, variable-length instructions that often take multiple cycles, poorer pipelineability, greater reliance on cache, programmable control units, and multiple instruction types that access memory directly.
5. Another way to compare the two architectures is that RISC processors favour many simple, fixed-length, single-cycle instructions, numerous registers, pipelining, and hardwired control units, whereas CISC processors favour a large and complex instruction set with variable-length instructions, many instruction formats and addressing modes, fewer registers, complex programmable control units, frequent cache use, and instructions that may internally be broken down into multiple micro-operations requiring several clock cycles.
6. Further contrasting RISC and CISC processors highlights that RISC designs emphasise a smaller instruction set, simpler and more uniform instruction formats, fixed-length instructions, extensive use of general-purpose registers, fewer addressing modes, simpler hardware implementation and better pipelines, while CISC designs emphasise a larger and richer instruction set, more complex and varied instruction formats, variable instruction lengths, fewer registers, more addressing modes, more complex hardware, and greater dependence on cache and multi-cycle instructions.

15.1b Pipelining and registers in RISC processors

7. Standard interrupt handling on both RISC and CISC processors involves completing the current instruction before responding, saving the program counter and register contents on a stack, using an interrupt vector and interrupt identifier to branch to the correct interrupt service routine, disabling further interrupts while the routine executes, servicing the interrupt, restoring the saved registers and program counter from the stack, re-enabling interrupts, and then resuming normal program execution.
8. In a pipelined RISC processor, multiple instructions are active simultaneously in different stages of the pipeline, so interrupts can occur at various pipeline stages and make handling more complex; the processor must either allow all instructions currently in the pipeline to complete before servicing the interrupt, or save the state of all in-flight instructions to the stack and later restore them, which increases the complexity and overhead of interrupt handling.

15.1e Virtual machines

9. Using a virtual machine to emulate a new computer system allows the new system to be tested on different virtual hardware without buying physical hardware, makes it easier to recover from crashes because the virtual machine protects other software on the host, enables programs for a new system that are incompatible with the host computer or operating system to run by using a guest operating system, and allows multiple operating systems to coexist on one physical machine, but virtual machines may not be able to emulate very new hardware developed after the virtual machine, introduce performance overhead and resource sharing that can degrade execution speed, and increase maintenance effort because both the host system and each virtual machine must be maintained.
10. The same emulation scenario also illustrates that virtual machines provide flexibility in trying systems on various virtual hardware configurations, strong isolation that limits the impact of crashes to the virtual environment, support for running software that is incompatible with the host’s native architecture or operating system via guest operating systems, and coexistence of multiple operating systems on one hardware platform, while simultaneously suffering from limitations such as incomplete hardware emulation for the newest devices, extra layers of code that reduce efficiency and share processor and memory resources, and additional maintenance overhead for multiple software stacks.
11. A virtual machine is an emulation of computer hardware and/or software that runs on a host computer using guest operating systems, and its advantages include the ability to run multiple guest operating systems or virtual machines on the same physical computer, emulate different instruction set architectures, allow a virtual machine to crash without affecting the host, offer security benefits when testing suspicious software because any infection is contained inside the virtual machine, reduce costs by avoiding the purchase of additional hardware, and run legacy applications that are otherwise incompatible with the current environment, while its disadvantages include lower efficiency and poorer performance due to extra load on the host, difficulty in accurately measuring performance inside the guest system, vulnerability to weaknesses in the host machine, complexity and cost of managing and maintaining virtualised environments, and the inability to emulate certain hardware devices.
