[
  {
    "point_id": "13.3",
    "question_number": "1A",
    "question": "Convert the denary value –35.125 into a fixed-point binary representation.",
    "mark_scheme": "This is intended as a paper exercise so the question of whether the value should be stored in a computer as sign and magnitude or two’s complement need not be considered.\nThe value in binary is simply –100011.001\n\nExplanation of the answer:\nWrite 35.125 in binary. 35 is 100011 and 0.125 is 0.001 because 1/8 equals 0.125.\nJoin them to get 100011.001, then add the negative sign for −35.125."
  },
  {
    "point_id": "13.3",
    "question_number": "1B",
    "question": "Why is the conversion of 25.33 into a fixed-point binary representation not as straightforward as the previous one?",
    "mark_scheme": "Because the fractional part cannot be expressed exactly.\n\nExplanation of the answer:\nSome decimal fractions do not end neatly in binary. 0.33 repeats forever in base 2, so you cannot write a finite exact binary for it. You must use an approximation."
  },
  {
    "point_id": "13.3",
    "question_number": "1C",
    "question": "Give a sensible value for 25.33 expressed in binary.",
    "mark_scheme": "The method described in worked example 16.01 in the coursebook must be used.\nA sensible value is 11001.0101.\nThe fraction .33 is approximated as .3125 (1/4 + 1/16).\nA more accurate binary value could be obtained by including more digits after the binary point but the progress towards a closer value would be slow.\n\nExplanation of the answer:\n25 is 11001 in binary. We choose 0.3125 as a close fraction to 0.33 because 0.3125 has a short binary 0.0101.\nPut them together to get 11001.0101. More binary places would improve the approximation slowly."
  },
  {
    "point_id": "13.3",
    "question_number": "1D",
    "question": "Is the value you have supplied appropriate for a signed fixed-point representation or for an unsigned one? Explain your reasoning.",
    "mark_scheme": "The value 11001.0101 is only suitable as an unsigned value. However, a more detailed answer could be provided which considers storage in a computer. The denary value is positive so the binary representation for a signed value must start with a zero. Provided that the storage space is large enough, a zero can be added at the start. This then automatically becomes a two’s complement value for a positive number.\n\nExplanation of the answer:\nFor signed two’s complement, positive numbers must begin with 0. The binary 11001.0101 starts with 1, so by itself it looks negative if treated as signed. Adding a leading 0 fixes that when stored in a wider signed field."
  },
  {
    "point_id": "13.3",
    "question_number": "2",
    "question": "A floating-point representation is based on the form represented by M × R^E.\nWhich of the following statements are correct?\nA M is referred to as the mantissa or significand and E is referred to as the exponent or exrad.\nB The binary code for a floating-point representation must have a defined number of bits for the mantissa and for the exponent.\nC A code for the value of the radix, R, has to be included in the binary code for the representation.\nD The representation must allow both the mantissa and the exponent to have a positive or negative value.\nE If the total number of bits is decided then the choice of bits used for the mantissa will decide the range of numbers that can be stored and the precision of the values stored.\nF If the number of bits for the mantissa is increased, the number of bits for the exponent must decrease so the precision will be improved but the range of values is decreased.\nG If the number of bits for the mantissa is increased, the number of bits for the exponent must decrease so the precision will be lower but the range of values is increased.",
    "mark_scheme": "A, B, D, E, F\nIt is necessary to remember which part is called the mantissa or significand. The most important aspect is that the designer of the floating point representation has an option as to how to divide the binary code, which affects the range of the values and their precision. The radix has an implied value of 2 so it does not need to have a code included.\n\nExplanation of the answer:\nWe store mantissa and exponent with fixed bit sizes. More mantissa bits give more precise digits, more exponent bits give a wider range of sizes. In base 2 systems we do not store R since it is always 2."
  },
  {
    "point_id": "13.3",
    "question_number": "3",
    "question": "Binary codes are shown for floating-point representations stored in two bytes. The first represents the mantissa in two’s complement form. The second represents the exponent in two’s complement form.\nFor ease of reading, there is a space separating the mantissa from the exponent. Match each code with the correct description.\n\n10000000 01111111\t\tLargest positive value\n11111111 10000000\t\tSmallest positive value\n01111111 01111111\t\tSmallest magnitude negative value\n00000001 10000000\t\tLargest magnitude negative value",
    "mark_scheme": "Learners often find this type of question problematic. A systematic approach is needed, looking at the mantissa and exponent separately. For each, the first bit sets the sign, 0 for positive and 1 for negative. Then it is necessary to remember that for a negative number in two’s complement the first bit represents a negative value but all of the others represent positive values.\n\nExplanation of the answer:\nDecide sign from the first bit of each field. Big positive numbers use a positive mantissa near 1 and a large positive exponent. Tiny positive numbers use a very small positive mantissa and a large negative exponent. The reverse gives large or tiny negatives."
  },
  {
    "point_id": "13.3",
    "question_number": "4",
    "question": "The following binary codes have the first six bits for the mantissa and the remaining four bits for the exponent (with a separating space for clarity). Match each code with the correct description.\n\n110010 0011\t\tUnnormalised form of –4.5\n100100 0010\t\tUnnormalised form of 2\n101110 0011\t\tNormalised form of 2\n110111 0100\t\tNormalised form of –4.5\n001000 0011\t\tUnnormalised form of –3.5\n010000 0010\t\tNormalised form of –3.5",
    "mark_scheme": "There are some straightforward rules here. The first bit defines the sign. If the next bit is different the representation is normalised. The binary point is initially after the first bit. To evaluate the number, the binary point has to be moved according to the value for the exponent. Three of these have exponent value 3 (0011) so the binary point moves three places right. Then the normal conversion of the binary can follow. Each one should be checked!\n\nExplanation of the answer:\nNormalised means the first two bits of the mantissa are different. Move the binary point by the exponent amount to get the value. Check sign first, then shift, then read the number."
  },
  {
    "point_id": "13.3",
    "question_number": "5A",
    "question": "A floating-point representation uses eight bits for the mantissa and four bits for the exponent. Both parts are stored in two's complement form.\nThe following are two examples:\n10101000 0111\n01101000 1000\nGive the denary equivalent of each.\n\n(Part A refers to 10101000 0111.)",
    "mark_scheme": "The mantissa for the first example is 1.0101000 and the exponent is denary 7, so the mantissa becomes 10101000.\nThis evaluates as -128 + 32 + 8 = -88\n\nExplanation of the answer:\n10101000 as an 8-bit two’s complement integer equals −128 + 32 + 8.\nThe exponent tells us how far the point was shifted, which leads to reading that mantissa as the stored integer pattern giving −88."
  },
  {
    "point_id": "13.3",
    "question_number": "5B",
    "question": "A floating-point representation uses eight bits for the mantissa and four bits for the exponent. Both parts are stored in two's complement form.\nThe following are two examples:\n10101000 0111\n01101000 1000\nGive the denary equivalent of each.\n\n(Part B refers to 01101000 1000.)",
    "mark_scheme": "For the second example the exponent is denary -8, so the mantissa becomes .000000001101000\nThis evaluates as 1/512 + 1/1024 + 1/4096 = 0.003173828\n\nExplanation of the answer:\nA negative exponent moves the binary point left. Moving by 8 places turns 01101000 into a very small fraction. Add the place values: 1/512 + 1/1024 + 1/4096."
  },
  {
    "point_id": "13.3",
    "question_number": "6A",
    "question": "For the same representation, give the values for the following:\nLargest magnitude positive value.",
    "mark_scheme": "01111111 0117\nThis is straightforward, with the biggest positive values for the mantissa and exponent, so both are filled with 1 bits following the 0 sign bit.\n\nExplanation of the answer:\nTo get the largest positive, choose the biggest positive mantissa pattern and biggest positive exponent. That gives a number close to 1 multiplied by a very large power of 2."
  },
  {
    "point_id": "13.3",
    "question_number": "6B",
    "question": "For the same representation, give the values for the following:\nSmallest magnitude positive value.",
    "mark_scheme": "00000001 1000\nThis answer ignores the value for zero. The smallest positive value must have all zeros in the mantissa except for the least significant bit. For the exponent, the initial 1 bit represents -8; if any other bit is 1, the exponent would be a positive value that lessens the magnitude. Note that the representation is NOT a normalised one. Floating-point processors have to decide whether or not to use unnormalised representations for numbers close to zero.\n\nExplanation of the answer:\nMake the mantissa as small as possible but not zero, then use the most negative exponent to push the point far left. This creates the tiniest positive number the format can hold."
  },
  {
    "point_id": "13.3",
    "question_number": "6C",
    "question": "For the same representation, give the values for the following:\nLargest magnitude negative value.",
    "mark_scheme": "10000000 0111\n\nExplanation of the answer:\nUse the same large exponent as for the largest positive, but make the mantissa negative by setting the sign bit to 1, which gives the most negative magnitude."
  },
  {
    "point_id": "13.3",
    "question_number": "6D",
    "question": "For the same representation, give the values for the following:\nSmallest magnitude negative value.",
    "mark_scheme": "11111111 1000\nAgain, this is unnormalised.\n\nExplanation of the answer:\nMirror the smallest positive idea but with a negative mantissa. Use the tiniest negative mantissa and the most negative exponent to get a value just below zero."
  },
  {
    "point_id": "13.3",
    "question_number": "7A",
    "question": "For each of the following, convert the stored value to a normalised representation:\n00101000 0110",
    "mark_scheme": "For the positive value the conversion is straightforward. The mantissa needs the bits moving one place to the left so the exponent must be reduced by one: 01010000 0105\n\nExplanation of the answer:\nTo normalise, shift the mantissa left until the first two bits differ. One left shift multiplies by 2, so reduce the exponent by 1 to keep the overall value the same."
  },
  {
    "point_id": "13.3",
    "question_number": "7B",
    "question": "For each of the following, convert the stored value to a normalised representation:\n11101000 0013",
    "mark_scheme": "It might appear strange that for the negative value, bits set to 1 can be moved off the left-hand end of the mantissa but that is what happens. The mantissa needs the bits moving two places to the left so the exponent must be reduced by two: 10100000 0001\n\nExplanation of the answer:\nNegative mantissas also get shifted until the first two bits differ. Two left shifts multiply by 4, so subtract 2 from the exponent to balance it."
  },
  {
    "point_id": "13.3",
    "question_number": "7C",
    "question": "After each conversion, check that the denary equivalent value has not changed.",
    "mark_scheme": "For the first value, the initial denary equivalent is 32 + 8 = 40 multiplied by 2^6, which is:\n40 × 64 = 2560.\nThe normalised version is 64 + 16 = 80 multiplied by 2^5, = 80 × 32 = 2560, which gives the same value.\nFor the second value, the initial denary equivalent is \n-128 + 64 + 32 + 8 = -24 multiplied by 2^3, which is -24 × 8 = -192.\nThe normalised version is -128 + 32 = -96 multiplied by 2^1, which gives the same value.\n\nExplanation of the answer:\nShifting the mantissa and adjusting the exponent by the same total amount keeps the product unchanged. Compute both versions to confirm they match."
  },
  {
    "point_id": "13.3",
    "question_number": "8A",
    "question": "In a particular computer system, real numbers are stored using floating-point representation with:\n• 8 bits for the mantissa\n• 8 bits for the exponent\n• two’s complement form for both mantissa and exponent.\nCalculate the floating point representation of +3.5 in this system. Show your working.",
    "mark_scheme": "0 1 1 1 0 0 0 0    0 0 0 0 0 0 1 0\n3.5 converts to 11.1 in binary, but 0 must be put at the start to ensure it is a positive value in two’s complement form.\nThen 011.1 has to be changed to 0.1110000 to produce a normalised representation that fits the 8-bit mantissa with the binary point in the correct position. This has involved a shift of the binary point by two places to the left so the exponent has to be the binary for 2.\n\nExplanation of the answer:\n3.5 is 11.1 in binary. Normalised form needs 0.111... so shift the point left 2 places, then record that shift with exponent 2. Keep a leading 0 to mark a positive mantissa in two’s complement."
  },
  {
    "point_id": "13.3",
    "question_number": "8B",
    "question": "Calculate the floating point representation of –3.5 in this system. Show your working.",
    "mark_scheme": "1 0 0 1 0 0 0 0    0 0 0 0 0 0 1 0\nAgain, this can begin by converting 3.5 to 011.1 in binary (the 0 must be placed at the start). To convert this to a negative value the two’s complement has to be taken, which produces 100.1. This is expanded to 1.0010000, which has involved a shift left of two places so the exponent is the binary for 2.\n\nExplanation of the answer:\nStart from the positive pattern, then take two’s complement to make it negative. Normalise by shifting left 2 places and set exponent to 2 so the overall value stays −3.5."
  },
  {
    "point_id": "13.3",
    "question_number": "8C",
    "question": "Find the denary value for the following binary floating-point number. Show your working.\nMantissa       -   Exponent \n0 1 1 1 0 0 0 0     -     0 0 0 0 0 1 0 0",
    "mark_scheme": "14\nThe exponent is 4 so the mantissa has to have the binary point shifted right by four places :\n0.1110000 becomes 01110.000. The denary is 8 + 4 + 2 = 14\n\nExplanation of the answer:\nExponent 4 means move the point 4 places right. The bits become 1110.000 which equals 8 + 4 + 2. Add them to get 14."
  },
  {
    "point_id": "13.3",
    "question_number": "8D(i)",
    "question": "State whether the floating-point number given in part (c) is normalised or not normalised.",
    "mark_scheme": "It is normalised\n\nExplanation of the answer:\nIn a normalised mantissa the first two bits differ. Here they are 0 and 1, so it is normalised."
  },
  {
    "point_id": "13.3",
    "question_number": "8D(ii)",
    "question": "Justify your answer given in part (d)(i).",
    "mark_scheme": "Because the two leftmost bits in the mantissa are different.\n\nExplanation of the answer:\nThe rule for this format is simple. If the first two mantissa bits are different, the number is in normalised form."
  },
  {
    "point_id": "13.3",
    "question_number": "8E",
    "question": "Give the binary two’s complement pattern for the negative number with the largest magnitude.\nMantissa Exponent",
    "mark_scheme": "1 0 0 1 0 0 0 0    0 1 1 1 1 1 1 1\n\nExplanation of the answer:\nUse the most negative mantissa pattern and the largest positive exponent. That combination gives the biggest magnitude below zero."
  },
  {
    "point_id": "13.3",
    "question_number": "9A(i)",
    "question": "State the values being represented by A, B and C.",
    "mark_scheme": "A = −1 + 1/4 × 2−1 = −3/4 × 1/2 = −3/8 = −0.375\nB = (1/2 + 1/8) × 23 = 5/8 × 8 = 5\nC = (1/8 + 1/32) × 25 = 5/32 × 32 = 5\n\nExplanation of the answer:\nEach value is mantissa times 2 to the exponent. Turn each fraction to a decimal or keep as fractions, then multiply by the power of 2. Compute A, B, and C separately."
  },
  {
    "point_id": "13.3",
    "question_number": "9A(ii)",
    "question": "Identify the value that is not normalised.",
    "mark_scheme": "C\n\nExplanation of the answer:\nCheck the first two mantissa bits. If they are the same it is not normalised. C fails the normalised rule."
  },
  {
    "point_id": "13.3",
    "question_number": "9A(iii)",
    "question": "Explain why it is normal for floating-point numbers to be normalised.",
    "mark_scheme": "Because there could be more than one way to represent the same value and some options are\nnot possible (e.g. 0.1000000 × 00000010 could become 0.0000000 × 00001001 which is not\npossible).\n\nExplanation of the answer:\nNormalising gives one standard form for each value. Without it, the same number could be stored in many ways, which causes confusion and wasted space."
  },
  {
    "point_id": "13.3",
    "question_number": "9B",
    "question": "Comment on the accuracy and range of numbers stored in this computer.",
    "mark_scheme": "Accuracy and range\n• 16-bit mantissa and 8-bit exponent gives high accuracy but small range.\n• Increasing mantissa size would increase accuracy further ….\n• …. but correspondingly reducing the exponent size would reduce the range (and the converse\nis true).\n\nExplanation of the answer:\nMore mantissa bits mean more precise digits. More exponent bits mean you can represent very big and very small numbers. If you increase one within a fixed word size, you must decrease the other."
  },
  {
    "point_id": "13.3",
    "question_number": "9C",
    "question": "Discuss the problems of representing the number zero in normalised floating-point format.",
    "mark_scheme": "Because normalised values must have 1.0 or 0.1 therefore it is not possible to store the value\nzero using this method.\n\nExplanation of the answer:\nNormalised mantissas always start with 1 or 0.1. Zero would need all zeros, which breaks that rule, so zero needs a special representation."
  },
  {
    "point_id": "13.3",
    "question_number": "10A(i)",
    "question": "A computer uses 12 bits for the mantissa and 6 bits for the exponent.\nConvert these binary floating-point numbers into denary.\n(i) [first given binary in the screenshot]",
    "mark_scheme": "(1/2 + 1/4 + 1/8 + 1/64) × 27 = 57/64 × 27 = 114\n\nExplanation of the answer:\nAdd the place values in the mantissa to get 57/64. Exponent 7 shifts the point right by 7 which multiplies by 2^7. Multiply to get 114."
  },
  {
    "point_id": "13.3",
    "question_number": "10A(ii)",
    "question": "A computer uses 12 bits for the mantissa and 6 bits for the exponent.\nConvert these binary floating-point numbers into denary.\n(ii) [second given binary in the screenshot]",
    "mark_scheme": "(−1 + 1/4 + 1/32 + 1/64 + 1/128) × 2−4 = −89/128 × 1/16 = −89/211 = 0.000434571\n\nExplanation of the answer:\nSum the signed fractional parts inside the mantissa to get −89/128. Exponent −4 moves the point left 4 places, which divides by 16. Compute the final decimal."
  },
  {
    "point_id": "13.3",
    "question_number": "10B(i)",
    "question": "Convert these denary numbers into binary floating-point numbers.\n(i) +4.75",
    "mark_scheme": "4.75 = 19/4 = 19/32 × 23 = 0.100110000000000 × 000011\n\nExplanation of the answer:\n4.75 is 100.11 in binary. Normalise to 0.10011 and record the shift by exponent 3. Pad with zeros to fit the mantissa length."
  },
  {
    "point_id": "13.3",
    "question_number": "10B(ii)",
    "question": "Convert these denary numbers into binary floating-point numbers.\n(ii) −8.375",
    "mark_scheme": "−8.375 = −67/8 = −67/128 × 24 = (−1 + 61/128) × 24\n= 1.011110100000000 × 000100\n\nExplanation of the answer:\n8.375 is 1000.011 in binary. Make it negative, normalise the mantissa, and set exponent 4 for the left shift. The given mantissa encodes the same value."
  },
  {
    "point_id": "13.3",
    "question_number": "11A",
    "question": "In a particular computer system, real numbers are stored using floating-point representation with:\n• 8 bits for the mantissa\n• 8 bits for the exponent\n• two’s complement form for both mantissa and exponent.\nCalculate the floating-point representation of +3.5 in this system. Show your working.",
    "mark_scheme": "01110000 00000010\n= 11.1\n= 0.11 × 22\n\nExplanation of the answer:\n3.5 equals 11.1. Normalise to 0.1110000 for an 8-bit mantissa and record a shift of 2 with the exponent. Keep the sign bit 0 for a positive mantissa."
  },
  {
    "point_id": "13.3",
    "question_number": "11B",
    "question": "Calculate the floating-point representation of −3.5 in this system. Show your working.",
    "mark_scheme": "10010000 00000010\nOne’s complement of 8-bit mantissa for +3.5 gives:\n10010000\n\nExplanation of the answer:\nBegin with the positive mantissa of 3.5. Convert to negative using complement, then use the same exponent as in the positive case because the magnitude is the same and the normalisation shift is the same."
  }
]