[
  {
    "point_id": "13.3",
    "question_number": "1A",
    "question": "Convert the denary value –35.125 into a fixed-point binary representation.",
    "mark_scheme": "100011.001\n\nExplanation of the answer:\nWrite 35.125 in binary. 35 is 100011 and 0.125 is 0.001 because 1/8 equals 0.125.\nJoin them to get 100011.001, then add the negative sign for −35.125."
  },
  {
    "point_id": "13.3",
    "question_number": "1B",
    "question": "Why is the conversion of 25.33 into a fixed-point binary representation not as straightforward as the previous one?",
    "mark_scheme": "Because the fractional part cannot be expressed exactly.\n\nExplanation of the answer:\nSome decimal fractions do not end neatly in binary. 0.33 repeats forever in base 2, so you cannot write a finite exact binary for it. You must use an approximation."
  },
  {
    "point_id": "13.3",
    "question_number": "1C",
    "question": "Give a sensible value for 25.33 expressed in binary.",
    "mark_scheme": "A sensible value is 11001.0101.\nThe fraction .33 is approximated as .3125 (1/4 + 1/16).\nA more accurate binary value could be obtained by including more digits after the binary point but the progress towards a closer value would be slow.\n\nExplanation of the answer:\n25 is 11001 in binary. We choose 0.3125 as a close fraction to 0.33 because 0.3125 has a short binary 0.0101.\nPut them together to get 11001.0101. More binary places would improve the approximation slowly."
  },
  {
    "point_id": "13.3",
    "question_number": "2",
    "question": "A floating-point representation is based on the form represented by M × R^E.\nWhich of the following statements are correct?\n-A. M is referred to as the mantissa or significand and E is referred to as the exponent or exrad.\n-B. The binary code for a floating-point representation must have a defined number of bits for the mantissa and for the exponent.\n-C. A code for the value of the radix, R, has to be included in the binary code for the representation.\n-D. The representation must allow both the mantissa and the exponent to have a positive or negative value.\n-E. If the total number of bits is decided then the choice of bits used for the mantissa will decide the range of numbers that can be stored and the precision of the values stored.\n-F. If the number of bits for the mantissa is increased, the number of bits for the exponent must decrease so the precision will be improved but the range of values is decreased.\n-G. If the number of bits for the mantissa is increased, the number of bits for the exponent must decrease so the precision will be lower but the range of values is increased.",
    "mark_scheme": "A, B, D, E, F\nIt is necessary to remember which part is called the mantissa or significand. The most important aspect is that the designer of the floating point representation has an option as to how to divide the binary code, which affects the range of the values and their precision. The radix has an implied value of 2 so it does not need to have a code included.\n\nExplanation of the answer:\nWe store mantissa and exponent with fixed bit sizes. More mantissa bits give more precise digits, more exponent bits give a wider range of sizes. In base 2 systems we do not store R since it is always 2."
  },
  {
    "point_id": "13.3",
    "question_number": "3",
    "question": "Binary codes are shown for floating-point representations stored in two bytes. The first represents the mantissa in two’s complement form. The second represents the exponent in two’s complement form.\nFor ease of reading, there is a space separating the mantissa from the exponent. Match each code with the correct description.\n\nList of codes: \n*10000000 01111111        \n*11111111 10000000        \n*01111111 01111111        \n*00000001 10000000    \n\nList of descriptions: \n *Largest positive value \n *Smallest positive value \n *Smallest magnitude negative value \n *Largest magnitude negative value",
    "mark_scheme": "Learners often find this type of question problematic. A systematic approach is needed, looking at the mantissa and exponent separately. For each, the first bit sets the sign, 0 for positive and 1 for negative. Then it is necessary to remember that for a negative number in two’s complement the first bit represents a negative value but all of the others represent positive values.\n\nMatchings\n\n- 10000000 01111111 → Largest magnitude negative value\n Mantissa 10000000 = −128; Exponent 01111111 = +127; Value = −128 × 2^127 (very large magnitude, negative).\n\n- 11111111 10000000 → Smallest magnitude negative value\n Mantissa 11111111 = −1; Exponent 10000000 = −128; Value = −1 × 2^−128 (very close to 0, negative).\n\n- 01111111 01111111 → Largest positive value\n Mantissa 01111111 = +127; Exponent 01111111 = +127; Value = +127 × 2^127 (very large magnitude, positive).\n\n- 00000001 10000000 → Smallest positive value\n Mantissa 00000001 = +1; Exponent 10000000 = −128; Value = +1 × 2^−128 (very close to 0, positive).\n\n---\n\nSystematic reasoning\n\n1. Interpret each 8-bit field separately as two’s complement.\n Sign bit 0 gives a non-negative value; sign bit 1 gives a negative value.\n\n2. Mantissas:\n 10000000 → −128\n 11111111 → −1\n 01111111 → +127\n 00000001 → +1\n\n3. Exponents:\n 01111111 → +127\n 10000000 → −128\n\n4. Combine as value = mantissa × 2^(exponent).\n Large positive values require a positive mantissa with a large positive exponent.\n Tiny positive values require a small positive mantissa with a large negative exponent.\n Large magnitude negatives mirror the same logic with negative mantissas.\n\n In other words:\nDecide sign from the first bit of each field. Big positive numbers use a positive mantissa near 1 and a large positive exponent. Tiny positive numbers use a very small positive mantissa and a large negative exponent. The reverse gives large or tiny negatives."
  },
  {
    "point_id": "13.3",
    "question_number": "4",
    "question": "The following binary codes have the first six bits for the mantissa and the remaining four bits for the exponent (with a separating space for clarity). Match each code with the correct description.\n\n List of codes:\n110010 0011\n100100 0010\n101110 0011\n110111 0100\n001000 0011\n010000 0010\n\n List of decriptions:\t\tUnnormalised form of –4.5\n\t\tUnnormalised form of 2\n\t\tNormalised form of 2\n\t\tNormalised form of –4.5\n\t\tUnnormalised form of –3.5\n\t\tNormalised form of –3.5",
	
	
	
    "mark_scheme": "There are some straightforward rules here. The first bit defines the sign. If the next bit is different the representation is normalised. The binary point is initially after the first bit. To evaluate the number, the binary point has to be moved according to the value for the exponent. Three of these have exponent value 3 (0011) so the binary point moves three places right. Then the normal conversion of the binary can follow. Each one should be checked!\n\n Matchings\n\n- 110010 0011 → Unnormalised form of –4.5\n- 100100 0010 → Normalised form of –4.5\n- 101110 0011 → Normalised form of –3.5\n- 110111 0100 → Unnormalised form of –3.5\n- 001000 0011 → Unnormalised form of 2\n- 010000 0010 → Normalised form of 2\n\n---\n\nSystematic reasoning\n\n1. First bit is the sign; next bit differs from the sign in a normalised mantissa, and matches it in an unnormalised mantissa.\n2. Treat the binary point as initially after the sign bit; move it right by the exponent’s value.\n3. Check sign, check normalised vs unnormalised, shift the point, then read the number.\n4. Pairs that differ by a one-place right shift of the mantissa and a +1 in the exponent represent the same value; the shifted one is unnormalised."
  },
  {
    "point_id": "13.3",
    "question_number": "5A",
    "question": "A floating-point representation uses eight bits for the mantissa and four bits for the exponent. Both parts are stored in two's complement form:\n10101000 0111\nGive the denary equivalent.",
    "mark_scheme": "The mantissa for the first example is 1.0101000 and the exponent is denary 7, so the mantissa becomes 10101000.\nThis evaluates as -128 + 32 + 8 = -88"
  },
  {
    "point_id": "13.3",
    "question_number": "5B",
    "question": "A floating-point representation uses eight bits for the mantissa and four bits for the exponent. Both parts are stored in two's complement form:\n01101000 1000\nGive the denary equivalent ",
    "mark_scheme": "For the second example the exponent is denary -8, so the mantissa becomes .000000001101000\nThis evaluates as 1/512 + 1/1024 + 1/4096 = 0.003173828\n\nExplanation of the answer:\nA negative exponent moves the binary point left. Moving by 8 places turns 01101000 into a very small fraction. Add the place values: 1/512 + 1/1024 + 1/4096."
  },
  {
    "point_id": "13.3",
    "question_number": "6A",
    "question": "For the same representation, give the values for the following:\nLargest magnitude positive value.",
    "mark_scheme": "01111111 0111\nThis is straightforward, with the biggest positive values for the mantissa and exponent, so both are filled with 1 bits following the 0 sign bit.\n\nExplanation of the answer:\nTo get the largest positive, choose the biggest positive mantissa pattern and biggest positive exponent. That gives a number close to 1 multiplied by a very large power of 2."
  },
  {
    "point_id": "13.3",
    "question_number": "6B",
    "question": "For the same representation, give the values for the following:\nSmallest magnitude positive value.",
    "mark_scheme": "00000001 1000\nThis answer ignores the value for zero. The smallest positive value must have all zeros in the mantissa except for the least significant bit. For the exponent, the initial 1 bit represents -8; if any other bit is 1, the exponent would be a positive value that lessens the magnitude. Note that the representation is NOT a normalised one. Floating-point processors have to decide whether or not to use unnormalised representations for numbers close to zero.\n\nExplanation of the answer:\nMake the mantissa as small as possible but not zero, then use the most negative exponent to push the point far left. This creates the tiniest positive number the format can hold."
  },
  {
    "point_id": "13.3",
    "question_number": "6C",
    "question": "For the same representation, give the values for the following:\nLargest magnitude negative value.",
    "mark_scheme": "10000000 0111\n\nExplanation of the answer:\nUse the same large exponent as for the largest positive, but make the mantissa negative by setting the sign bit to 1, which gives the most negative magnitude."
  },
  {
    "point_id": "13.3",
    "question_number": "6D",
    "question": "For the same representation, give the values for the following:\nSmallest magnitude negative value.",
    "mark_scheme": "11111111 1000\nAgain, this is unnormalised.\n\nExplanation of the answer:\nMirror the smallest positive idea but with a negative mantissa. Use the tiniest negative mantissa and the most negative exponent to get a value just below zero."
  },
  {
    "point_id": "13.3",
    "question_number": "7A",
    "question": "Convert the stored value to a normalised representation:\n00101000 0110",
    "mark_scheme": "For the positive value the conversion is straightforward. The mantissa needs the bits moving one place to the left so the exponent must be reduced by one: 01010000 0101\n\nExplanation of the answer:\nTo normalise, shift the mantissa left until the first two bits differ. One left shift multiplies by 2, so reduce the exponent by 1 to keep the overall value the same.\nMantissa 00101000 has first two bits 00, so it is unnormalised.\nShift left once → 01010000. Now the first two bits differ (01), so it is normalised.\nOne left shift multiplies the mantissa by 2, so reduce the exponent 0110 (6) by 1 → 0101 (5)."
  },
  {
    "point_id": "13.3",
    "question_number": "7B",
    "question": "Convert the stored value to a normalised representation:\n11101000 0011",
    "mark_scheme": "Mantissa 11101000 is negative and unnormalised since the first two bits are 11.\nShift left twice: 11101000 → 11010000 → 10100000. Now the first two bits are 10, so it is normalised.\nTwo left shifts multiply the mantissa by 4, so subtract 2 from the exponent 0011 (3) to get 0001 (1).\nIt might appear strange that for the negative value, bits set to 1 can be moved off the left-hand end of the mantissa but that is what happens. The mantissa needs the bits moving two places to the left so the exponent must be reduced by two: 10100000 0001\n\nNegative mantissas also get shifted until the first two bits differ. Two left shifts multiply by 4, so subtract 2 from the exponent to balance it."
  },
  {
    "point_id": "13.3",
    "question_number": "8A",
    "question": "In a particular computer system, real numbers are stored using floating-point representation with:\n• 8 bits for the mantissa\n• 8 bits for the exponent\n• two’s complement form for both mantissa and exponent.\nCalculate the floating point representation of +3.5 in this system. Show your working.",
    "mark_scheme": "01110000 00000010\n3.5 converts to 11.1 in binary, but 0 must be put at the start to ensure it is a positive value in two’s complement form.\nThen 011.1 has to be changed to 0.1110000 to produce a normalised representation that fits the 8-bit mantissa with the binary point in the correct position. This has involved a shift of the binary point by two places to the left so the exponent has to be the binary for 2.\n\nExplanation of the answer:\n3.5 is 11.1 in binary. Normalised form needs 0.111... so shift the point left 2 places, then record that shift with exponent 2. Keep a leading 0 to mark a positive mantissa in two’s complement."
  },
  {
    "point_id": "13.3",
    "question_number": "8B",
    "question": "Calculate the floating point representation of –3.5 in this system. Show your working.",
    "mark_scheme": "10010000 00000010\nAgain, this can begin by converting 3.5 to 011.1 in binary (the 0 must be placed at the start). To convert this to a negative value the two’s complement has to be taken, which produces 100.1. This is expanded to 1.0010000, which has involved a shift left of two places so the exponent is the binary for 2.\n\nExplanation of the answer:\nStart from the positive pattern, then take two’s complement to make it negative. Normalise by shifting left 2 places and set exponent to 2 so the overall value stays −3.5."
  },
  {
    "point_id": "13.3",
    "question_number": "8C",
    "question": "Find the denary value for the following binary floating-point number. Show your working.\n01110000 00000100",
    "mark_scheme": "14\nThe exponent is 4 so the mantissa has to have the binary point shifted right by four places :\n0.1110000 becomes 01110.000. The denary is 8 + 4 + 2 = 14\n\nExplanation of the answer:\nExponent 4 means move the point 4 places right. The bits become 1110.000 which equals 8 + 4 + 2. Add them to get 14."
  },
  {
    "point_id": "13.3",
    "question_number": "8D(i)",
    "question": "State whether the floating-point number given in part (c) is normalised or not normalised.",
    "mark_scheme": "It is normalised\n\nExplanation of the answer:\nIn a normalised mantissa the first two bits differ. Here they are 0 and 1, so it is normalised."
  },
  {
    "point_id": "13.3",
    "question_number": "8D(ii)",
    "question": "Justify your answer given in part (d)(i).",
    "mark_scheme": "Because the two leftmost bits in the mantissa are different.\n\nExplanation of the answer:\nThe rule for this format is simple. If the first two mantissa bits are different, the number is in normalised form."
  }
]